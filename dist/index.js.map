{"version":3,"sources":["webpack://dpack/webpack/universalModuleDefinition","webpack://dpack/webpack/bootstrap","webpack://dpack/./browser.js","webpack://dpack/./fetch.js","webpack://dpack/./lib/Options.js","webpack://dpack/./lib/parse.js","webpack://dpack/./lib/serialize.js","webpack://dpack/(webpack)/buildin/global.js","webpack://dpack/./xhr.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","serialize","parse","Options","createSerializer","createParser","fetch","XMLHttpRequest","readResponse","response","onProgress","reader","body","getReader","Promise","resolve","reject","parser","parsedData","queuedBytes","queueUnfinishedChar","bytes","length","lastStart","byte","needs","slice","decoder","TextDecoder","readNext","read","then","next","done","sourceText","decode","Uint8Array","Array","from","concat","onResume","updatedData","setSource","url","request","headers","fetchResponse","dpack","this","classByName","Map","converterByConstructor","addExtension","Class","options","set","fromArray","toArray","FALSE","TRUE","DEFAULT_TYPE","ARRAY_TYPE","REFERENCING_TYPE","NUMBER_TYPE","METADATA_TYPE","REFERENCING_POSITION","TYPE_DEFINITION","OPEN_SEQUENCE","END_SEQUENCE","DEFERRED_REFERENCE","offset","source","isPartial","pausedState","deferredReads","pause","state","lastRead","previous","resume","Error","nextString","isPartialString","rebuildString","resumeState","disposedChars","readSequence","thisProperty","isArray","propertyState","propertyIndex","values","nextPosition","push","code","constructs","type","number","token","charCodeAt","resetTo","parent","undefined","forDeferred","previousProperty","recordValueReference","extendedType","fromValue","errorOnUnknownClass","parameter","metadata","readMap","readSet","readDate","string","startOffset","hasMoreData","isPaused","hasUnfulfilledReferences","index","getOffset","shared","deferredRead","target","parentDeferredReads","targetProperty","result","null","assign","constructor","setPrototypeOf","getPrototypeOf","error","message","stringOrBuffer","toString","encoding","entries","map","entry","Set","size","add","time","Date","PROPERTY_CODE","TYPE_CODE","STRING_CODE","NUMBER_CODE","SEQUENCE_CODE","NULL","UNDEFINED","nextId","extendedTypes","toValue","writeMap","writeSet","writeDate","outlet","avoidShareUpdate","propertyUsed","charEncoder","global","Buffer","serialized","writeToken","serializedToken","String","fromCharCode","writeString","getSerialized","startSequence","endSequence","browserCharEncoder","nodeCharEncoder","writeBuffer","forProperty","pendingEncodings","bufferSymbol","targetSymbol","serializerId","writers","writeAsDefault","writeAsArray","writeAsReferencing","writeAsNumber","writeInlineString","serializer","reference","indexOf","writeNumber","writeSharedValue","writeTypedValue","writeProperty","writeTypedNonConstant","parentProperty","notPlainObject","writeBlockReference","iterator","iterable","arrayProperty","child","writeAsIterable","resumeIndex","lastPropertyIndex","getProperty","console","array","needsClosing","block","writer","blockProperty","lazyPromise","callback","forBlock","buffer","lastPendingEncodings","unshift","apply","sharedProperty","promises","finished","promise","shift","all","flush","setOffset","getWriters","startWrite","endWrite","sizeTable","sizeTableSymbol","lazy","ArrayFrom","keyValue","forEach","keyValues","date","getTime","g","Function","eval","e","acceptSet","xhr","addEventListener","receivedData","originalSetRequestHeader","setRequestHeader","lastOffset","toLowerCase","originalSend","send","event","responseText","responseParsed","test","getResponseHeader","onerror","arguments"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dpack\"] = factory();\n\telse\n\t\troot[\"dpack\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./browser.js\");\n","var serialize = require('./lib/serialize')\r\nvar parse = require('./lib/parse')\r\nvar Options = require('./lib/Options').Options\r\n\r\nexports.serialize = serialize.serialize\r\nexports.parse = parse.parse\r\nexports.createSerializer = serialize.createSerializer\r\nexports.createParser = parse.createParser\r\nexports.Options = Options\r\nexports.fetch = require('./fetch').fetch\r\nexports.XMLHttpRequest = require('./xhr').XMLHttpRequest\r\n","\"use strict\"\r\nvar createParser = require('./lib/parse').createParser\r\n\r\nvar serialize = require('./lib/serialize').serialize\r\nfunction readResponse(response, onProgress) {\r\n\tvar reader = response.body.getReader()\r\n\treturn new Promise(function(resolve, reject) {\r\n\t\tvar parser\r\n\t\tvar parsedData\r\n\t\tvar queuedBytes\r\n\t\tfunction queueUnfinishedChar(bytes) {\r\n\t\t\t// this checks to see if we end the bytes in the middle of a character, and need to queue bytes for the next chunk\r\n\t\t\tvar length = bytes.length\r\n\t\t\tvar lastStart = length - 1\r\n\t\t\tif (bytes[lastStart] < 0x80) {\r\n\t\t\t\tqueuedBytes = null\r\n\t\t\t\treturn bytes\r\n\t\t\t}\r\n\t\t\twhile (lastStart >= 0) {\r\n\t\t\t\tvar byte = bytes[lastStart]\r\n\t\t\t\tif (byte >= 0xC0) {\r\n\t\t\t\t\tvar charLength = byte >= 0xE0 ? byte >= 0xF0 ? 4 : 3 : 2\r\n\t\t\t\t\tvar needs = charLength - length + lastStart\r\n\t\t\t\t\tif (needs > 0) {\r\n\t\t\t\t\t\tqueuedBytes = bytes.slice(lastStart, length - lastStart)\r\n\t\t\t\t\t\tqueuedBytes.needs = needs\r\n\t\t\t\t\t\treturn bytes.slice(0, lastStart)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tqueuedBytes = null\r\n\t\t\t\t\treturn bytes\r\n\t\t\t\t}\r\n\t\t\t\tlastStart--\r\n\t\t\t}\r\n\t\t\tqueuedBytes = null\r\n\t\t\treturn bytes\r\n\t\t}\r\n\t\tvar decoder = new TextDecoder()\r\n\t\tfunction readNext() {\r\n\t\t\treader.read().then(function(next) {\r\n\t\t\t\tif (next.done) {\r\n\t\t\t\t\tresolve(parsedData)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar bytes = next.value\r\n\t\t\t\t\tvar sourceText\r\n\t\t\t\t\tif (queuedBytes) {\r\n\t\t\t\t\t\t// if we are resuming from the middle of a character, concatenate the bytes and decode it\r\n\t\t\t\t\t\tsourceText = decoder.decode(new Uint8Array(Array.from(queuedBytes).concat(Array.from(bytes.slice(0, queuedBytes.needs)))))\r\n\t\t\t\t\t\t// and then remove the consumed byte(s)\r\n\t\t\t\t\t\tbytes = bytes.slice(queuedBytes.needs)\r\n\t\t\t\t\t\tbytes = queueUnfinishedChar(bytes)\r\n\t\t\t\t\t\tsourceText += decoder.decode(bytes)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbytes = queueUnfinishedChar(bytes)\r\n\t\t\t\t\t\tsourceText = decoder.decode(bytes)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parser) {\r\n\t\t\t\t\t\tif (parser.onResume) {\r\n\t\t\t\t\t\t\tvar updatedData = parser.onResume(sourceText, true)\r\n\t\t\t\t\t\t\tparsedData = parsedData || updatedData\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tparser = createParser()\r\n\t\t\t\t\t\tparser.setSource(sourceText, 0, true)\r\n\t\t\t\t\t\tparsedData = parser.read()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tparser.read()\r\n\t\t\t\t\treadNext()\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction onError(error) {\r\n\t\t\tif (error.message == 'Unexpected end of dpack stream') {\r\n\t\t\t\tparsedData = parsedData || error.valueInProgress\r\n\t\t\t\tif (onProgress) {\r\n\t\t\t\t\tonProgress(parsedData, response)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treject(error)\r\n\t\t\t}\r\n\t\t}\r\n\t\treadNext()\r\n\t})\r\n}\r\nexports.readResponse = readResponse\r\nexports.fetch = function(url, request) {\r\n\t(request.headers || (request.headers = {}))['Accept'] = 'text/dpack;q=1,application/json;q=0.7'\r\n\tvar fetchResponse = fetch(url, request)\r\n\tfetchResponse.then(function(response) {\r\n\t\tresponse.dpack = function(onProgress) {\r\n\t\t\treturn readResponse(response, onProgress)\r\n\t\t}\r\n\t\treturn response\r\n\t})\r\n\treturn fetchResponse\r\n}\r\n","\"use strict\"\r\nfunction Options() {\r\n\tvar classByName = this.classByName = new Map()\r\n\tthis.converterByConstructor = new Map()\r\n\t//writerByConstructor.set(Map, writeMap)\r\n\t//writerByConstructor.set(Set, writeSet)\r\n}\r\nOptions.prototype.addExtension = function(Class, name, options) {\r\n\tif (name && Class.name !== name) {\r\n\t\tClass.name = name\r\n\t}\r\n\tthis.classByName.set(Class.name, (options && options.fromArray) ? options : Class)\r\n\tthis.converterByConstructor.set(Class, (options && options.toArray) ? options : Class)\r\n}\r\nexports.Options = Options\r\n","\"use strict\"\r\n\r\n// type codes:\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\n\r\nvar MAX_LENGTH = 1024*1024*16\r\nvar PAUSED = {}\r\n\r\nfunction createParser(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar offset\r\n\tvar source\r\n\tvar isPartial\r\n\tvar classByName = options.classByName || new Map()\r\n\tclassByName.set('Map', readMap)\r\n\tclassByName.set('Set', readSet)\r\n\tclassByName.set('Date', readDate)\r\n\tvar pausedState\r\n\tvar deferredReads\r\n\r\n\tfunction pause(state, lastRead) {\r\n\t\tstate.previous = pausedState\r\n\t\tstate.resume = true\r\n\t\tpausedState = state\r\n\t\tif (!isPartial)\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\r\n\t\tif (!parser.onResume) // only if not already defined, otherwise we just want to use the one from the top of the call stack\r\n\t\t\tparser.onResume = function(nextString, isPartialString, rebuildString) {\r\n\t\t\t\t// top of the resume stack\r\n\t\t\t\tvar resumeState = pausedState\r\n\t\t\t\tpausedState = null\r\n\t\t\t\tparser.onResume = null\r\n\t\t\t\t// we slice and add these together to generate an entirely new string\r\n\t\t\t\t// so we don't cause a memory leak with redundant strings that a retained a slice parents\r\n\t\t\t\tif (lastRead < source.length)\r\n\t\t\t\t\tsource = source.slice(lastRead) + nextString\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (rebuildString) // if we have read all of source, we want to slice and re-concatenate to eliminate the slice reference to the parent, we really don't want that retained in memory\r\n\t\t\t\t\t\tsource = nextString.slice(0, 1) + nextString.slice(1)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tsource = nextString\r\n\t\t\t\t}\r\n\t\t\t\tisPartial = isPartialString\r\n\t\t\t\tdisposedChars += lastRead\r\n\t\t\t\toffset = 0\r\n\t\t\t\treturn resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState)\r\n\t\t\t}\r\n\t\treturn state.object\r\n\t}\r\n\r\n\tfunction readSequence(length, thisProperty) {\r\n\t\t/* propertyStates:\r\n\t\t0 - starting next property slot\r\n\t\t1 - property created, succeeding value should be value of property\r\n\t\t2 - property creation in progress, next value should define key\r\n\t\t11+ - modifying property, next value modifies property (adds metadata, position, type, etc.)\r\n\t\t*/\r\n\t\tvar propertyState = 0\r\n\t\tthisProperty = thisProperty || []\r\n\t\tvar property, isArray, object, value, i = 0, propertyIndex = 0\r\n\t\tif (thisProperty.resume) { // resuming, thisProperty is the resume state.\r\n\t\t\tproperty = thisProperty.previous\r\n\t\t\tif (property) {\r\n\t\t\t\t// do the previous/upper stack frame first\r\n\t\t\t\tvar value = property.reader ? property.reader(property) : readSequence(property.length, property)\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (values) {\r\n\t\t\t\t\t// we have an assignment to referencing values that is waiting for pausing to complete\r\n\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t// if still paused, pass on to next pausedState\r\n\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.nextPosition > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references, and when the position is reset\r\n\t\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (thisProperty.code && thisProperty.code !== thisProperty.thisProperty.code) {\r\n\t\t\t\tthisProperty.resume = false // if the resume property has been reassigned to an incompatible type, can't switch\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ti = thisProperty.i || 0\r\n\t\t\t\tobject = thisProperty.object\r\n\t\t\t\tpropertyState = thisProperty.propertyState || 0\r\n\t\t\t\tpropertyIndex = thisProperty.propertyIndex || 0\r\n\t\t\t\tthisProperty = thisProperty.thisProperty\r\n\t\t\t}\r\n\t\t}\r\n\t\tisArray = thisProperty.code === ARRAY_TYPE/*ARRAY_TYPE*/\r\n\t\tobject = object || (thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {}) // TODO: we could probably construct a new reader that does this a little faster\r\n\t\tfor (; i < length;) {\r\n\t\t\tvar type, number\r\n\t\t\tvar lastRead = offset\r\n\t\t\tvar token = source.charCodeAt(offset++)\r\n\t\t\tif (token >= 0x30) { // fast path for one byte with stop bit\r\n\t\t\t\tif (token > 0x3000) { // long-token handling\r\n\t\t\t\t\ttype = (token >>> 12) ^ 4\r\n\t\t\t\t\tnumber = token & 0xfff\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = (token >>> 4) ^ 4\r\n\t\t\t\t\tnumber = token & 0xf\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttype = (token >>> 4) & 11 // shift and omit the stop bit (bit 3)\r\n\t\t\t\tnumber = token & 0xf\r\n\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 10 bit number\r\n\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 16 bit number\r\n\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 22 bit number\r\n\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 28 bit number\r\n\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)\r\n\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 40 bit number\r\n\t\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 46 bit number, we don't go beyond this\r\n\t\t\t\t\t\t\t\t\t\tif (!(token >= 0)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (type === 0) { /*PROPERTY_CODE*/\r\n\t\t\t\tpropertyIndex = number\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tif (type === 3) { /*TYPE_CODE*/\r\n\t\t\t\t// we store the previous property state in token, so we can assign the next one\r\n\t\t\t\tif (number < 6) {\r\n\t\t\t\t\t// special values (constants, deferreds)\r\n\t\t\t\t\tif (number < 3) {\r\n\t\t\t\t\t\tif (number === 0) {\r\n\t\t\t\t\t\t\tvalue = null\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = 'Unknown token, type: ' + type + ' number: ' + number\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number === TRUE) {\r\n\t\t\t\t\t\t\tvalue = true\r\n\t\t\t\t\t\t} else if (number === FALSE) {\r\n\t\t\t\t\t\t\tvalue = false\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = undefined\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (number <= NUMBER_TYPE) {\r\n\t\t\t\t\t\t// property definition\r\n\t\t\t\t\t\tif (propertyState === 1) {\r\n\t\t\t\t\t\t\t// we were in property value position, but no value, so we increment position here\r\n\t\t\t\t\t\t\tpropertyIndex++\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\t\tthrow new Error('Overwriting frozen property')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\t\tif (!property.resume) {\r\n\t\t\t\t\t\t\t\tvalue = property.key // inherit the existing key\r\n\t\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\t\tproperty.key = value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { // no property existed in slot, start with default key of null\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.code = number\r\n\t\t\t\t\t\tproperty.parent = thisProperty\r\n\t\t\t\t\t\t//property.key = null\r\n\t\t\t\t\t\tpropertyState = 2 // read next value as the key\r\n\t\t\t\t\t\tif (number === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\t\t\t\tproperty.values = []\r\n\t\t\t\t\t\t} else if (number === ARRAY_TYPE) {\r\n\t\t\t\t\t\t\tproperty[0] = []\r\n\t\t\t\t\t\t\tproperty[0].key = null\r\n\t\t\t\t\t\t\tproperty[0].code = DEFAULT_TYPE\r\n\t\t\t\t\t\t\tproperty[0].parent = property\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// property modification\r\n\t\t\t\t\t\tpropertyState = number\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (type === 2 /*STRING_CODE*/) {\r\n\t\t\t\t\tvalue = source.slice(offset, offset += number)\r\n\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\tpropertyState: propertyState\r\n\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyState < 2) {\r\n\t\t\t\t\t\tif (property.code === NUMBER_TYPE/*NUMBER_TYPE*/) {\r\n\t\t\t\t\t\t\tvalue = +value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (type === 1) { /*NUMBER_CODE*/\r\n\t\t\t\t\tvalue = number\r\n\t\t\t\t} else { /*if type == 7 SEQUENCE_CODE*/\r\n\t\t\t\t\tif (number > 13) {\r\n\t\t\t\t\t\tif (number === END_SEQUENCE)\r\n\t\t\t\t\t\t\treturn object\r\n\t\t\t\t\t\telse if (number === DEFERRED_REFERENCE) {\r\n\t\t\t\t\t\t\tvalue = readSequence(0, property)\r\n\t\t\t\t\t\t\tpropertyState = 0\r\n\t\t\t\t\t\t\tif (options.forDeferred) {\r\n\t\t\t\t\t\t\t\tvalue = options.forDeferred(value, property)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t(deferredReads || (deferredReads = [])).push({\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number >= OPEN_SEQUENCE) {\r\n\t\t\t\t\t\t\tnumber = 2000000000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyState > 1) {\r\n\t\t\t\t\t\t\tif (propertyState === 2) {\r\n\t\t\t\t\t\t\t\tpropertyState = 0 // if the property key was skipped, go directly into value mode\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t\t} else if (propertyState === METADATA_TYPE)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, [{ key: null, code: 6 }])\r\n\t\t\t\t\t\t\telse if (property.resume && (property.code || DEFAULT_TYPE) === property.thisProperty.code)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property.thisProperty)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t\tif (value === undefined) { // or a PAUSED object\r\n\t\t\t\t\t\t\t\tpausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here\r\n\t\t\t\t\t\t\t\tparser.onResume = null\r\n\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// need to assign the values *after* the completion of the sequence if it is a forward reference\r\n\t\t\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}/*else if (values) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property) {\r\n\t\t\t\tthrow new Error('No property defined for slot' + (thisProperty.key ? ' in ' + thisProperty.key : ''))\r\n\t\t\t}\r\n\t\t\tif (propertyState < 2 && property && property.code === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (typeof value === 'number') {\r\n\t\t\t\t\tvalue = values[number]\r\n\t\t\t\t\tif (value === undefined && !((number) in values)) {\r\n\t\t\t\t\t\tthrow new Error('Referencing value that has not been read yet')\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t} else if ((type === 2 || type === 7) && values) { // only strings and sequences\r\n\t\t\t\t\tif (values.nextPosition > -1) {\r\n\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\tif (property.recordValueReference) {\r\n\t\t\t\t\t\t\tproperty.recordValueReference(values)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (propertyState > 1) {\r\n\t\t\t\t// 0, 1: values are the value of the property\r\n\t\t\t\tif (propertyState === 2) { // property key\r\n\t\t\t\t\tproperty.key = value\r\n\t\t\t\t} else if (propertyState === METADATA_TYPE) { // 3: metadata paramater\r\n\t\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\t\tvar extendedType = classByName.get(value)\r\n\t\t\t\t\t\tif (extendedType) {\r\n\t\t\t\t\t\t\tif (extendedType.fromValue) {\r\n\t\t\t\t\t\t\t\tproperty.fromValue = extendedType.fromValue\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tproperty.constructs = extendedType\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (options.errorOnUnknownClass) {\r\n\t\t\t\t\t\t\tthrow new Error('Attempt to deserialize to unknown class ' + parameter)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t//\treadingProperty.readValue = readAsDefault\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.extendedType = extendedType // if this gets used for serialization, this is needed\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// extended metadata assignment (used by shared structures to mark objects as unstructured)\r\n\t\t\t\t\t\tproperty.metadata = value\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (propertyState === REFERENCING_POSITION) {\r\n\t\t\t\t\tvar values = property.values || (property.values = [])\r\n\t\t\t\t\t//values.splice(value, values.length)\r\n\t\t\t\t\tvalues.nextPosition = value\r\n\t\t\t\t} else if (propertyState === TYPE_DEFINITION) { // for type-only state\r\n\t\t\t\t\t// throw away this value and read next value as the real value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Unknown property type ' + propertyState)\r\n\t\t\t\t}\r\n\t\t\t\tpropertyState = 1 // property value after definition position\r\n\t\t\t\tcontinue // read next value as the property value\r\n\t\t\t} else {\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t}\r\n\t\t\tif (property.fromValue) {\r\n\t\t\t\tvalue = property.fromValue(value)\r\n\t\t\t}\r\n\t\t\tif (isArray && property.key === null) {\r\n\t\t\t\tobject.push(value)\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tobject[property.key] = value\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t\tif (!isArray)\r\n\t\t\t\tpropertyIndex++\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\r\n\tfunction unknownType(number) {\r\n\t\tthrow new Error('Unknown type ' + number)\r\n\t}\r\n\r\n\tvar disposedChars = 0\r\n\tfunction read(property) {\r\n\t\ttry {\r\n\t\t\tif (property && property.resume) {\r\n\t\t\t\tvar previous = property.previous\r\n\t\t\t\tvalue = readSequence(previous.length, previous)\r\n\t\t\t\t// once we get the value, we don't know which point in the stack could still be resolving\r\n\t\t\t\tvalue = property.object || value\r\n\t\t\t\tproperty = property.property\r\n\t\t\t} else {\r\n\t\t\t\tproperty = property || [options && options.shared || {\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tcode: 6\r\n\t\t\t\t}]\r\n\t\t\t\tvar value = readSequence(1, property)[property[0].key]\r\n\t\t\t}\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (pausedState) {\r\n\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\treader: read,\r\n\t\t\t\t\t\tobject: value,\r\n\t\t\t\t\t\tproperty: property\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (!deferredReads) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tvar index = deferredReads.index || 0\r\n\t\t\t\tvar deferredRead = deferredReads[index]\r\n\t\t\t\tdeferredReads.index = index + 1\r\n\t\t\t\tif (!deferredRead) {\r\n\t\t\t\t\tdeferredReads = deferredReads.parent\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar target = deferredRead.value\r\n\t\t\t\tvar parentDeferredReads = deferredReads\r\n\t\t\t\tdeferredReads = []\r\n\t\t\t\tdeferredReads.parent = parentDeferredReads\r\n\t\t\t\tvar targetProperty = deferredRead.property\r\n\t\t\t\tvar result = readSequence(1, property = [{\r\n\t\t\t\t\tresume: true,\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tthisProperty: targetProperty,\r\n\t\t\t\t\tobject: target\r\n\t\t\t\t}])\r\n\t\t\t\tresult = result.null || result[targetProperty.key] // Blocks should use null as the root key, but could have the target property key as well\r\n\t\t\t\tif (result != target) { // This should only occur with a promise that resolves to a different type, an array\r\n\t\t\t\t\t// object was replaced with something else (an array, presumably)\r\n\t\t\t\t\tObject.assign(target, result)\r\n\t\t\t\t\tif (pausedState && pausedState.object === result) {\r\n\t\t\t\t\t\tpausedState.object = target\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result && result.constructor === Array) {\r\n\t\t\t\t\t\ttarget.length = result.length\r\n\t\t\t\t\t\tObject.setPrototypeOf(target, Object.getPrototypeOf(result)) // do our best to make it array like\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(error) {\r\n\t\t\terror.message = 'DPack parsing error: ' + error.message + ' at position: ' + (offset + disposedChars) + ' near: ' + source.slice(offset - 10, offset + 10)\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar parser = {\r\n\t\tsetSource: function(string, startOffset, isPartialString) {\r\n\t\t\tsource = string\r\n\t\t\toffset = startOffset || 0\r\n\t\t\tdisposedChars = 0\r\n\t\t\tisPartial = isPartialString\r\n\t\t\treturn this\r\n\t\t},\r\n\t\thasMoreData: function() {\r\n\t\t\treturn source.length > offset\r\n\t\t},\r\n\t\tisPaused: function() {\r\n\t\t\treturn pausedState\r\n\t\t},\r\n\t\thasUnfulfilledReferences: function() {\r\n\t\t\treturn deferredReads && deferredReads.length > deferredReads.index\r\n\t\t},\r\n\t\tgetOffset: function() {\r\n\t\t\treturn offset + disposedChars\r\n\t\t},\r\n\t\tread: read\r\n\t}\r\n\treturn parser\r\n}\r\nexports.parse = function(stringOrBuffer, options) {\r\n\tvar source\r\n\tif (typeof stringOrBuffer === 'string') {\r\n\t\tsource = stringOrBuffer\r\n\t} else if (stringOrBuffer && stringOrBuffer.toString) {\r\n\t\tsource = stringOrBuffer.toString(options && options.encoding || 'utf8')\r\n\t} else { // whatever (undefined or null or whatever), just return it\r\n\t\treturn stringOrBuffer\r\n\t}\r\n\tvar parser = createParser(options).setSource(source)\r\n\tif (options && options.shared)\r\n\t\treturn parser.read([options.shared])\r\n\treturn parser.read()\r\n}\r\nexports.createParser = createParser\r\n\r\nvar readMap = {\r\n\tfromValue: function(entries) {\r\n\t\tvar map = new Map()\r\n\t\tfor (var i = 0, l = entries.length; i < l; i++) {\r\n\t\t\tvar entry = entries[i]\r\n\t\t\tmap.set(entry.key, entry.value)\r\n\t\t}\r\n\t\treturn map\r\n\t}\r\n}\r\nvar readSet = {\r\n\tfromValue: function(values) {\r\n\t\tvar set = new Set(values)\r\n\t\tif (set.size === 0 && values.length > 0) {\r\n\t\t\tfor (var i = 0, l = values.length; i < l; i++) {\r\n\t\t\t\tset.add(values[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn set\r\n\t}\r\n}\r\nvar readDate = {\r\n\tfromValue: function(time) {\r\n\t\treturn new Date(time)\r\n\t}\r\n}\r\n\r\n","\"use strict\"\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\nvar nextId = 1\r\n\r\nfunction createSerializer(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar extendedTypes = options.converterByConstructor\r\n\tif (!extendedTypes) {\r\n\t\textendedTypes = new Map()\r\n\t}\r\n\textendedTypes.set(Map, {\r\n\t\tname: 'Map',\r\n\t\ttoValue: writeMap\r\n\t})\r\n\textendedTypes.set(Set, {\r\n\t\tname: 'Set',\r\n\t\ttoValue: writeSet\r\n\t})\r\n\textendedTypes.set(Date, {\r\n\t\tname: 'Date',\r\n\t\ttoValue: writeDate\r\n\t})\r\n\tvar avoidShareUpdate = options.outlet || options.avoidShareUpdate\r\n\tvar charEncoder = (typeof global != 'undefined' && global.Buffer && !(options && options.encoding === 'utf16le')) ? exports.nodeCharEncoder(options) : browserCharEncoder(options)\r\n\tvar writeString = charEncoder.writeString\r\n\tvar writeToken = charEncoder.writeToken\r\n\tvar startSequence = charEncoder.startSequence\r\n\tvar endSequence = charEncoder.endSequence\r\n\tvar writeBuffer = charEncoder.writeBuffer\r\n\tvar forProperty = options.forProperty\r\n\tvar propertyUsed\r\n\tvar valueUsed\r\n\tif (options.shared) {\r\n\t\tpropertyUsed = options.shared.propertyUsed\r\n\t\tvalueUsed = options.shared.propertyUsed\r\n\t}\r\n\tvar pendingEncodings = []\r\n\tvar nextPropertyIndex = 8\r\n\tvar property\r\n\tvar bufferSymbol = exports.bufferSymbol || '_bufferSymbol_'\r\n\tvar targetSymbol = exports.targetSymbol || '_targetSymbol_'\r\n\tvar propertyComparisons = 0\r\n\tvar serializerId = nextId++\r\n\r\n\tvar writers = [\r\n\t\t0, 1, 2, 3, 4 , 5,\r\n\t\twriteAsDefault,\r\n\t\twriteAsArray,\r\n\t\twriteAsReferencing,\r\n\t\twriteAsNumber,\r\n\t\twriteOnlyNull\r\n\t]\r\n\t// write a rudimentary number\r\n\tfunction writeNumber(number) {\r\n\t\twriteToken(NUMBER_CODE, number)\r\n\t}\r\n\t// write a rudimentary string\r\n\tfunction writeInlineString(string) {\r\n\t\twriteToken(STRING_CODE, string.length)\r\n\t\twriteString(string)\r\n\t}\r\n\r\n\t// writing any value in referencing serialization type mode\r\n\tfunction writeAsReferencing(value) {\r\n\t\tvar type, values = property.values\r\n\t\tif (values) {\r\n\t\t\tif (values.resetTo > -1 && values.serializer !== serializerId) {\r\n\t\t\t\t// if this is a shared values, need to reset on each serialization\r\n\t\t\t\tvalues.serializer = serializerId\r\n\t\t\t\tif (values.resetTo < values.length)\r\n\t\t\t\t\tvalues.length = values.resetTo\r\n\t\t\t\twriteToken(TYPE_CODE, REFERENCING_POSITION)\r\n\t\t\t\twriteToken(NUMBER_CODE, values.resetTo)\r\n\t\t\t}\r\n\t\t\tvar reference = values.indexOf(value)\r\n\t\t\tif (reference > -1) {\r\n\t\t\t\treturn writeNumber(reference)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((type = typeof value) === 'string' || type ==='object' && value) {\r\n\t\t\tif (property.writeSharedValue) {\r\n\t\t\t\tif (property.writeSharedValue(value, writeToken, serializerId))\r\n\t\t\t\t\treturn\r\n\t\t\t} else if (values) {\r\n\t\t\t\tvar index = values.length\r\n\t\t\t\tif (index < 12)\r\n\t\t\t\t\tvalues[index] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type === 'string') {\r\n\t\t\twriteInlineString(value)\r\n\t\t} else {\r\n\t\t\twriteAsDefault(value)\r\n\t\t}\r\n\t}\r\n\r\n\t// writing any value in number serialization type mode\r\n\tfunction writeAsNumber(number) {\r\n\t\tvar type = typeof number\r\n\t\tif (type === 'number') {\r\n\t\t\tif (number >>> 0 === number || (number > 0 && number < 0x400000000000 && number % 1 === 0)) {\r\n\t\t\t\t// 46 bit unsigned integer\r\n\t\t\t\twriteToken(NUMBER_CODE, number)\r\n\t\t\t} else {\r\n\t\t\t\t// decimal number serialized as a string\r\n\t\t\t\tvar asString = number.toString()\r\n\t\t\t\twriteInlineString(asString)\r\n\t\t\t}\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteAsDefault(number)\r\n\t\t} else {\r\n\t\t\twriteTypedValue(number)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedValue(value) {\r\n\t\tif (value === null)\r\n\t\t\twriteToken(TYPE_CODE, NULL)\r\n\t\telse if (value === false)\r\n\t\t\twriteToken(TYPE_CODE, FALSE)\r\n\t\telse if (value === true)\r\n\t\t\twriteToken(TYPE_CODE, TRUE)\r\n\t\telse if (value === undefined)\r\n\t\t\twriteToken(TYPE_CODE, UNDEFINED)\r\n\t\telse {\r\n\t\t\twriteTypedNonConstant(value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedNonConstant(value) {\r\n\t\tvar type = typeof value\r\n\t\tvar extendedType\r\n\t\tif (type === 'object') {\r\n\t\t\tif (value) {\r\n\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t// leave type as is\r\n\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\ttype = 'array'\r\n\t\t\t\t} else {\r\n\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property.type === type) {\r\n\t\t\t\t\t\t\t// if we are the right type after doing the conversion, go back to the original property to serialize\r\n\t\t\t\t\t\t\tif (property.extendedType !== extendedType) {\r\n\t\t\t\t\t\t\t\tproperty.extendedType = extendedType\r\n\t\t\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn writers[property.code](value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t} else { // null\r\n\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t}\r\n\t\t} else if (type === 'boolean') {\r\n\t\t\ttype = 'undefined'\r\n\t\t} else if (type === 'function') {\r\n\t\t\tvalue = value.toString()\r\n\t\t\ttype = 'string'\r\n\t\t}\r\n\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\twriters[property.code](value)\r\n\t}\r\n\r\n\tfunction writeOnlyNull() {\r\n\t\twriteToken(TYPE_CODE, NULL)\r\n\t}\r\n\r\n\t// writing any value in default serialization type mode\r\n\tfunction writeAsDefault(value, parentProperty) {\r\n\t\tvar type = typeof value\r\n\t\tif (type === 'object') {\r\n\t\t\tif (!value) {\r\n\t\t\t\treturn writeToken(TYPE_CODE, NULL)\r\n\t\t\t}\r\n\t\t\t// else continue with the object code\r\n\t\t} else if (type === 'string') {\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\t// 46 bit unsigned integer\r\n\t\t\treturn writeToken(NUMBER_CODE, value)\r\n\t\t} else {\r\n\t\t\treturn writeTypedValue(value)\r\n\t\t}\r\n\t\tvar object = value\r\n\t\tvar constructor = object.constructor\r\n\t\tvar notPlainObject\r\n\t\tif (object[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(value)\r\n\t\t} else if (constructor === Object) {\r\n\t\t\tnotPlainObject = false\r\n\t\t} else if (constructor === Array) {\r\n\t\t\tproperty = writeProperty(property.key, 'array')\r\n\t\t\treturn writers[property.code](value, parentProperty)\r\n\t\t} else {\r\n\t\t\tif (object.then) {\r\n\t\t\t\treturn writeBlockReference(value)\r\n\t\t\t}\r\n\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\tif (extendedType) {\r\n\t\t\t\tif (extendedType.toValue) {\r\n\t\t\t\t\treturn writeTypedValue(object)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\textendedTypes.set(constructor, extendedType = {\r\n\t\t\t\t\tname: constructor.name\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (property.constructs !== constructor) {\r\n\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\tproperty.constructs = constructor\r\n\t\t\t}\r\n\t\t\tif (typeof Symbol !== 'undefined' && object[Symbol.iterator]) {\r\n\t\t\t\twriteProperty(property.key, 'array')\r\n\t\t\t\twriteAsIterable(object)\r\n\t\t\t}\r\n\t\t\tnotPlainObject = true\r\n\t\t}\r\n\t\tvar thisProperty = property\r\n\t\tif (thisProperty.resetTo < thisProperty.length && thisProperty.serializer != serializerId) {\r\n\t\t\tthisProperty.length = thisProperty.resetTo\r\n\t\t\tthisProperty.serializer = serializerId\r\n\t\t}\r\n\t\tstartSequence()\r\n\t\tvar i = 0\r\n\t\t//var sparse = false // densely packed property references can be searched more quickly\r\n\t\tvar resumeIndex = -2 // -2 denotes densely packed property references \r\n\t\tvar propertyIndex = 0\r\n\t\tfor (var key in object) {\r\n\t\t\tif (notPlainObject && !object.hasOwnProperty(key))\r\n\t\t\t\tcontinue\r\n\t\t\tvar value = object[key]\r\n\t\t\ttype = typeof value\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tvar constructor\r\n\t\t\tvar extendedType = false\r\n\t\t\tif (type === 'object') {\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tconstructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // null\r\n\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined (and boolean), both constants that can go in any type\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property || property.key !== key ||\r\n\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\tvar lastPropertyIndex = propertyIndex\r\n\t\t\t\t// property doesn't match, search for it through existing properties\r\n\t\t\t\t// note that we are starting at the current propertyIndex, so this makes the assumption that\r\n\t\t\t\t// properties are rarely ever swapped, so possible property slots are always forward\r\n\t\t\t\tif (resumeIndex > -2)\r\n\t\t\t\t\tpropertyIndex = resumeIndex\r\n\t\t\t\tdo {\r\n\t\t\t\t\tproperty = thisProperty[++propertyIndex]\r\n\t\t\t\t} while(property && (property.key !== key ||\r\n\t\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\t// found a match, reference it\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (thisProperty.getProperty) {\r\n\t\t\t\t\t// a shared property, let it allocate ids\r\n\t\t\t\t\tproperty = thisProperty.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex)\r\n\t\t\t\t\tpropertyIndex = property.index\r\n\t\t\t\t\tif (lastPropertyIndex !== propertyIndex && resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastPropertyIndex === thisProperty.length) {\r\n\t\t\t\t\t\tpropertyIndex = lastPropertyIndex\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex = thisProperty.length)\r\n\t\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\tdebugger\r\n\t\t\t\t\t\tthrow new Error('overwriting frozen property')\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tproperty = thisProperty[propertyIndex] = writeProperty(key, type, extendedType)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (propertyUsed)\r\n\t\t\t\tpropertyUsed(property, object, serializerId, i)\r\n//\t\t\tif (property.resumeIndex) // TODO: add a flag to enable this when property ordering can be assumed\r\n//\t\t\t\tresumeIndex = property.resumeIndex\r\n\t\t\tvar code = property.code\r\n\t\t\tif (code > 7) {\r\n\t\t\t\tif (code === 8)\r\n\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t} else {\r\n\t\t\t\tif (code === 6) \r\n\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsArray(value)\r\n\t\t\t}\r\n\t\t\tpropertyIndex++\r\n\t\t\ti++\r\n\t\t}\r\n\t\tproperty = thisProperty\r\n\t\tendSequence(i)\r\n\t}\r\n\r\n\tfunction writeProperty(key, type, extendedType) {\r\n\t\tvar property\r\n\t\tproperty = []\r\n\t\tproperty.key = key\r\n\t\tproperty.type = type\r\n\t\tif (type === 'string') {\r\n\t\t\twriteToken(TYPE_CODE, REFERENCING_TYPE)\r\n\t\t\tproperty.values = []\r\n\t\t\tproperty.code = REFERENCING_TYPE\r\n\t\t} else if (type === 'number') {\r\n\t\t\twriteToken(TYPE_CODE, NUMBER_TYPE)\r\n\t\t\tproperty.code = NUMBER_TYPE\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else if (type === 'array') {\r\n\t\t\twriteToken(TYPE_CODE, ARRAY_TYPE)\r\n\t\t\tproperty.code = ARRAY_TYPE\r\n\t\t} else if (type === 'boolean' || type === 'undefined') {\r\n\t\t\tproperty.type = 'object'\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = 10\r\n\t\t\tconsole.error('Unable to write value of type ' + type)\r\n\t\t}\r\n\r\n\t\tif (typeof key === 'string') {\r\n\t\t\twriteInlineString(key)\r\n\t\t} else if (!(key === null && (type === 'object' || type === 'array'))) { // if key is null followed by sequence, we can elide the key\r\n\t\t\twriteAsDefault(key)\r\n\t\t}\r\n\t\tif (extendedType) {\r\n\t\t\tproperty.extendedType = extendedType\r\n\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\twriteInlineString(extendedType.name)\r\n\t\t}\r\n\t\treturn property\r\n\t}\r\n\r\n\tfunction writeAsIterable(iterable) {\r\n\t\twriteToken(SEQUENCE_CODE, 15)\r\n\t\tvar iterator = iterable[Symbol.iterator]()\r\n\t\tvar arrayProperty = property\r\n\t\tproperty = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property\r\n\t\t// write out the elements\r\n\t\tvar result\r\n\t\twhile(!(result = iterator.next()).done) {\r\n\t\t\twriters[property.code](result.value, arrayProperty)\r\n\t\t}\r\n\t\tif (property !== arrayProperty.child) {\r\n\t\t\t// TODO: This really needs to happen immediately when a property changes, to match the parsing behavior\r\n\t\t\tarrayProperty.child = property\r\n\t\t}\r\n\t\tproperty = arrayProperty // restore current property\r\n\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t}\r\n\r\n\tfunction writeAsArray(array, parentProperty) {\r\n\t\tif (!array) {\r\n\t\t\twriteTypedValue(array)\r\n\t\t} else if (array[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(array)\r\n\t\t} else if (array.constructor === Array) { // check to make sure it is an array\r\n\t\t\tvar length = array.length\r\n\t\t\tvar needsClosing\r\n\t\t\tif (length > 11) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE) // start sequence <\r\n\t\t\t\tneedsClosing = true\r\n\t\t\t} else {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, length) // write out the header token\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty[0] // set the current property to the child property\r\n\t\t\t// check to see if needs to be reset before starting\r\n\t\t\tif (arrayProperty.resetTo < arrayProperty.length && arrayProperty.serializer != serializerId) {\r\n\t\t\t\tarrayProperty.length = arrayProperty.resetTo\r\n\t\t\t\tarrayProperty.serializer = serializerId\r\n\t\t\t}\r\n\t\t\tvar propertyIndex = 0\r\n\t\t\t// write out the elements\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tvar value = array[i]\r\n\t\t\t\tvar type = typeof value\r\n\t\t\t\tif (type === 'object') {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar extendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { // null\r\n\t\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!property) {\r\n\t\t\t\t\tif (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, 0)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type === 'string' || type === 'number' || type === 'array')\r\n\t\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// default doesn't have to be written\r\n\t\t\t\t\t\t\tproperty = []\r\n\t\t\t\t\t\t\tproperty.type = type\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tarrayProperty[0] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\t\tpropertyIndex = -1\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tproperty = arrayProperty[++propertyIndex]\r\n\t\t\t\t\t} while(property && ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t} else if (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, -1)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\tarrayProperty[propertyIndex] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (propertyUsed)\r\n\t\t\t\t\tpropertyUsed(property, array, serializerId, i)\r\n\t\t\t\tvar code = property.code\r\n\t\t\t\tif (code > 7) {\r\n\t\t\t\t\tif (code === 8)\r\n\t\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (code === 6) \r\n\t\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsArray(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (needsClosing) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t\t\t}\r\n\t\t\tproperty = arrayProperty // restore current property\r\n\t\t} else { // bail to default mode behavior\r\n\t\t\twriteTypedValue(array)\r\n\t\t}\r\n\t}\r\n\r\n\tvar blockProperty\r\n\r\n\tfunction writeBlockReference(block, writer) {\r\n\t\twriteToken(SEQUENCE_CODE, DEFERRED_REFERENCE)\r\n\t\tvar blockProperty = property\r\n\t\tvar lazyPromise = block[targetSymbol] ? {\r\n\t\t\tthen: then\r\n\t\t} : {\r\n\t\t\tthen: function(callback) {\r\n\t\t\t\treturn block.then(function(value) {\r\n\t\t\t\t\tblock = value\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction then(callback) {\r\n\t\t\tif (options.forBlock) {\r\n\t\t\t\t// this is used by the sizeTable serializer to record the size of each block\r\n\t\t\t\toptions.forBlock(block, blockProperty)\r\n\t\t\t} else {\r\n\t\t\t\tvar buffer = block && block[bufferSymbol] && block[bufferSymbol](blockProperty)\r\n\t\t\t\tif (buffer) {\r\n\t\t\t\t\twriteBuffer(buffer)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperty = blockProperty\r\n\t\t\t\t\tvar lastPendingEncodings = pendingEncodings\r\n\t\t\t\t\tpendingEncodings = [] // record any nested pending encoding separately\r\n\t\t\t\t\twriteAsDefault(block) // write it out as the next block\r\n\t\t\t\t\tlastPendingEncodings.unshift.apply(lastPendingEncodings, pendingEncodings) // and splice them in front\r\n\t\t\t\t\tpendingEncodings = lastPendingEncodings\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcallback()\r\n\t\t}\r\n\t\tpendingEncodings.push(lazyPromise)\r\n\t}\r\n\r\n\tvar serializer = {\r\n\t\tserialize: function(value, sharedProperty) {\r\n\t\t\tvar buffer = value && value[bufferSymbol] && value[bufferSymbol](sharedProperty)\r\n\r\n\t\t\tif (buffer) {\r\n\t\t\t\tcharEncoder.writeBuffer(buffer)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (sharedProperty) {\r\n\t\t\t\tproperty = sharedProperty\r\n\t\t\t\twriters[property.code](value)\r\n\t\t\t} else {\r\n\t\t\t\tproperty = []\r\n\t\t\t\tproperty.key = null\r\n\t\t\t\twriteAsDefault(value)\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetSerialized: function() {\r\n\t\t\tif (pendingEncodings.length > 0) {\r\n\t\t\t\tvar promises = []\r\n\t\t\t\twhile (pendingEncodings.length > 0) {\r\n\t\t\t\t\tvar finished = false\r\n\t\t\t\t\tvar promise = pendingEncodings.shift().then(function() {\r\n\t\t\t\t\t\tfinished = true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\tpromises.push(promise)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (promises.length > 0) {\r\n\t\t\t\t\treturn Promise.all(promises).then(function() {\r\n\t\t\t\t\t\treturn serializer.getSerialized()\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (options && options.encoding === 'utf16le') {\r\n\t\t\t\treturn Buffer.from(charEncoder.getSerialized(), 'utf16le')\r\n\t\t\t}\r\n\t\t\treturn charEncoder.getSerialized()\r\n\t\t},\r\n\t\tflush: charEncoder.flush,\r\n\t\tsetOffset: charEncoder.setOffset,\r\n\t\tpendingEncodings: pendingEncodings,\r\n\t\tgetWriters: function() {\r\n\t\t\treturn {\r\n\t\t\t\twriteProperty: writeProperty,\r\n\t\t\t\twriteToken: writeToken,\r\n\t\t\t\twriteAsDefault: writeAsDefault,\r\n\t\t\t\twriteBuffer: writeBuffer\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn serializer\r\n}\r\nfunction serialize(value, options) {\r\n\tvar serializer = createSerializer(options)\r\n\tvar sharedProperty = options && options.shared\r\n\tvar buffer\r\n\tif (sharedProperty && sharedProperty.startWrite) {\r\n\t\t// record the start of each write\r\n\t\tsharedProperty.startWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tserializer.serialize(value, sharedProperty)\r\n\tbuffer = serializer.getSerialized()\r\n\tif (sharedProperty && sharedProperty.endWrite) {\r\n\t\t// record the end of each write\r\n\t\tsharedProperty.endWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tvar sizeTable = value && value[exports.sizeTableSymbol]\r\n\tif (sizeTable) {\r\n\t\tbuffer.sizeTable = sizeTable\r\n\t}\r\n\r\n\tif (options && options.lazy) {\r\n\t\treturn Buffer.concat([value[exports.sizeTableSymbol], buffer])\r\n\t}\r\n\treturn buffer\r\n}\r\nexports.serialize = serialize\r\nexports.createSerializer = createSerializer\r\nfunction browserCharEncoder() {\r\n\tvar serialized = ''\r\n\tfunction writeToken(type, number) {\r\n\t\tvar serializedToken\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(((type << 4) | number) ^ 0x40)\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 6),\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 12),\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 18),\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 24),\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 30),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000 >>> 0),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x1000000000 >>> 0),\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000000 >>> 0),\r\n\t\t\t\t(number / 0x1000000000) & 0x3f,\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else {\r\n\t\t\tthrow new Error('Too big of number')\r\n\t\t}\r\n\t\tserialized += serializedToken\r\n\t}\r\n\tfunction writeString(string) {\r\n\t\tserialized += string\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn serialized\r\n\t}\r\n\treturn {\r\n\t\twriteToken: writeToken,\r\n\t\twriteString: writeString,\r\n\t\t//writeBuffer,\r\n\t\tgetSerialized: getSerialized,\r\n\t\t//insertBuffer,\r\n\t\t//flush,\r\n\t\tstartSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t},\r\n\t\tendSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE)\r\n\t\t},\r\n\t\tgetOffset: function() {// unsupported\r\n\t\t\treturn -1\r\n\t\t}\r\n\t}\r\n}\r\nvar ArrayFrom = Array.from || function(iterable, keyValue) {\r\n\tvar array = []\r\n\tvar keyValue = iterable.constructor === Map\r\n\titerable.forEach(function(key, value) {\r\n\t\tif (keyValue) {\r\n\t\t\tarray.push([value, key])\r\n\t\t} else {\r\n\t\t\tarray.push(key)\r\n\t\t}\r\n\t})\r\n\treturn array\r\n}\r\n\r\nfunction writeMap(map) {\r\n\tvar keyValues = ArrayFrom(map)\r\n\tfor (var i = 0, length = keyValues.length; i < length; i++) {\r\n\t\tvar keyValue = keyValues[i]\r\n\t\tkeyValues[i] = {\r\n\t\t\tkey: keyValue[0],\r\n\t\t\tvalue: keyValue[1]\r\n\t\t}\r\n\t}\r\n\treturn keyValues\r\n}\r\nfunction writeSet(set) {\r\n\treturn ArrayFrom(set)\r\n}\r\nfunction writeDate(date) {\r\n\treturn date.getTime()\r\n}","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\"use strict\"\r\nvar createParser = require('./lib/parse').createParser\r\n\r\nexports.XMLHttpRequest = function() {\r\n\tvar xhr = new XMLHttpRequest()\r\n\tvar parser\r\n\tvar responseResolve\r\n\tvar responseRejected\r\n   \tvar requestResolved\r\n\txhr.addEventListener('progress', receivedData)\r\n\tvar acceptSet\r\n\tvar originalSetRequestHeader = xhr.setRequestHeader\r\n\tvar lastOffset = 0\r\n\txhr.setRequestHeader = function(name, value) {\r\n\t\tif (name.toLowerCase() == 'accept')\r\n\t\t\tacceptSet = true\r\n\t\treturn originalSetRequestHeader.call(this, name, value)\r\n\t}\r\n\tvar originalSend = xhr.send\r\n\txhr.send = function() {\r\n\t\tif (!acceptSet)\r\n\t\t\tthis.setRequestHeader('Accept', 'text/dpack;q=1,application/json;q=0.7')\r\n\t\toriginalSend.apply(this, arguments)\r\n\t}\r\n\r\n\tfunction receivedData(event) {\r\n\t\tvar sourceText = xhr.responseText\r\n\t\ttry {\r\n\t\t\tif (parser) {\r\n\t\t\t\tif (parser.onResume) {\r\n\t\t\t\t\tvar updatedData = parser.onResume(sourceText.slice(lastOffset), true, true)\r\n\t\t\t\t\txhr.responseParsed = xhr.responseParsed || updatedData\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (sourceText && /dpack/.test(xhr.getResponseHeader('Content-Type'))) {\r\n\t\t\t\t\tparser = createParser()\r\n\t\t\t\t\tparser.setSource(sourceText, 0, true)\r\n\t\t\t\t\txhr.responseParsed = parser.read()\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tlastOffset = sourceText.length\r\n\t\t} catch (error) {\r\n\t\t\tif (xhr.onerror) {\r\n\t\t\t\txhr.onerror(error)\r\n\t\t\t} else {\r\n\t\t\t\tthrow error\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\txhr.addEventListener('load', function(event) {\r\n\t\treceivedData()\r\n\t\tif (parser && parser.isPaused()) {\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\t\t}\r\n\t})\r\n\treturn xhr\r\n}\r\n"],"sourceRoot":""}