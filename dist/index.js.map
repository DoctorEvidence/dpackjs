{"version":3,"sources":["webpack://dpack/webpack/universalModuleDefinition","webpack://dpack/webpack/bootstrap","webpack://dpack/./browser.js","webpack://dpack/./fetch.js","webpack://dpack/./lib/Block.js","webpack://dpack/./lib/Options.js","webpack://dpack/./lib/binary-parse.js","webpack://dpack/./lib/parse.js","webpack://dpack/./lib/serialize.js","webpack://dpack/(webpack)/buildin/global.js","webpack://dpack/./xhr.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,0CAA0C,2BAA2B,qBAAqB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,uFAAuF;AACvF;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,QAAQ,YAAY;AACpB;AACA;AACA;AACA,uBAAuB;AACvB,yBAAyB;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI,uBAAuB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE,OAAO;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;8CCxmBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,IAAI,OAAO;AACX;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK,OAAO;AACZ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F;AAC/F;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;;;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA,iBAAiB,uBAAuB;AACxC,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,GAAG,2BAA2B;AAC9B;AACA;AACA;AACA,GAAG,6BAA6B;AAChC;AACA;AACA;AACA;AACA,GAAG,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA,GAAG,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,iCAAiC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,iCAAiC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,mCAAmC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,oCAAoC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;;;;;ACxxBA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;ACnBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qBAAqB;AACpE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dpack\"] = factory();\n\telse\n\t\troot[\"dpack\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./browser.js\");\n","var serialize = require('./lib/serialize')\r\nvar parse = require('./lib/parse')\r\nvar Options = require('./lib/Options').Options\r\n\r\nexports.serialize = serialize.serialize\r\nexports.parse = parse.parse\r\nexports.createSerializer = serialize.createSerializer\r\nexports.createParser = parse.createParser\r\nexports.parseLazy = parse.parseLazy\r\nexports.asBlock = require('./lib/Block').asBlock\r\nexports.Options = Options\r\nexports.fetch = require('./fetch').fetch\r\nexports.XMLHttpRequest = require('./xhr').XMLHttpRequest\r\n","\"use strict\"\r\nvar createParser = require('./lib/parse').createParser\r\n\r\nwindow.createParser = createParser\r\nvar serialize = window.serialize = require('./lib/serialize').serialize\r\nfunction readResponse(response, onProgress) {\r\n\tvar reader = response.body.getReader()\r\n\treturn new Promise(function(resolve, reject) {\r\n\t\tvar parser\r\n\t\tvar parsedData\r\n\t\tvar queuedBytes\r\n\t\tfunction queueUnfinishedChar(bytes) {\r\n\t\t\t// this checks to see if we end the bytes in the middle of a character, and need to queue bytes for the next chunk\r\n\t\t\tvar length = bytes.length\r\n\t\t\tvar lastStart = length - 1\r\n\t\t\tif (bytes[lastStart] < 0x80) {\r\n\t\t\t\tqueuedBytes = null\r\n\t\t\t\treturn bytes\r\n\t\t\t}\r\n\t\t\twhile (lastStart >= 0) {\r\n\t\t\t\tvar byte = bytes[lastStart]\r\n\t\t\t\tif (byte >= 0xC0) {\r\n\t\t\t\t\tvar charLength = byte >= 0xE0 ? byte >= 0xF0 ? 4 : 3 : 2\r\n\t\t\t\t\tvar needs = charLength - length + lastStart\r\n\t\t\t\t\tif (needs > 0) {\r\n\t\t\t\t\t\tqueuedBytes = bytes.slice(lastStart, length - lastStart)\r\n\t\t\t\t\t\tqueuedBytes.needs = needs\r\n\t\t\t\t\t\treturn bytes.slice(0, lastStart)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tqueuedBytes = null\r\n\t\t\t\t\treturn bytes\r\n\t\t\t\t}\r\n\t\t\t\tlastStart--\r\n\t\t\t}\r\n\t\t\tqueuedBytes = null\r\n\t\t\treturn bytes\r\n\t\t}\r\n\t\tvar decoder = new TextDecoder()\r\n\t\tfunction readNext() {\r\n\t\t\treader.read().then(function(next) {\r\n\t\t\t\tif (next.done) {\r\n\t\t\t\t\tresolve(parsedData)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar bytes = next.value\r\n\t\t\t\t\tvar sourceText\r\n\t\t\t\t\tif (queuedBytes) {\r\n\t\t\t\t\t\t// if we are resuming from the middle of a character, concatenate the bytes and decode it\r\n\t\t\t\t\t\tsourceText = decoder.decode(new Uint8Array(Array.from(queuedBytes).concat(Array.from(bytes.slice(0, queuedBytes.needs)))))\r\n\t\t\t\t\t\t// and then remove the consumed byte(s)\r\n\t\t\t\t\t\tbytes = bytes.slice(queuedBytes.needs)\r\n\t\t\t\t\t\tbytes = queueUnfinishedChar(bytes)\r\n\t\t\t\t\t\tsourceText += decoder.decode(bytes)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tbytes = queueUnfinishedChar(bytes)\r\n\t\t\t\t\t\tsourceText = decoder.decode(bytes)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (parser) {\r\n\t\t\t\t\t\tif (parser.onResume) {\r\n\t\t\t\t\t\t\tvar updatedData = parser.onResume(sourceText, true)\r\n\t\t\t\t\t\t\tparsedData = parsedData || updatedData\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tparser = createParser()\r\n\t\t\t\t\t\tparser.setSource(sourceText, 0, true)\r\n\t\t\t\t\t\tparsedData = parser.read()\r\n\t\t\t\t\t}\r\n\t\t\t\t\tparser.read()\r\n\t\t\t\t\treadNext()\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t}\r\n\t\tfunction onError(error) {\r\n\t\t\tif (error.message == 'Unexpected end of dpack stream') {\r\n\t\t\t\tparsedData = parsedData || error.valueInProgress\r\n\t\t\t\tif (onProgress) {\r\n\t\t\t\t\tonProgress(parsedData, response)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treject(error)\r\n\t\t\t}\r\n\t\t}\r\n\t\treadNext()\r\n\t})\r\n}\r\nexports.readResponse = readResponse\r\nexports.fetch = function(url, request) {\r\n\t(request.headers || (request.headers = {}))['Accept'] = 'text/dpack;q=1,application/json;q=0.7'\r\n\tvar fetchResponse = fetch(url, request)\r\n\tfetchResponse.then(function(response) {\r\n\t\tresponse.dpack = function(onProgress) {\r\n\t\t\treturn readResponse(response, onProgress)\r\n\t\t}\r\n\t\treturn response\r\n\t})\r\n\treturn fetchResponse\r\n}\r\n","\"use strict\"\r\nconst BLOCK_TYPE = 5\r\nvar makeSymbol = typeof Symbol !== 'undefined' ? Symbol : function(name) {\r\n\treturn 'symbol-' + name\r\n}\r\nvar bufferSymbol = makeSymbol('buffer')\r\nvar headerSymbol = makeSymbol('header')\r\nvar parsedSymbol = makeSymbol('parsed')\r\n\r\nfunction Block() {}\r\nexports.Block = Block\r\nexports.bufferSymbol = bufferSymbol\r\nexports.parsedSymbol = parsedSymbol\r\nvar serialize = require('./serialize').serialize\r\nvar createBinaryParser = require('./binary-parse').createParser\r\nexports.asBlock = function(object) {\r\n\tif (object && object.constructor === Block) {\r\n\t\treturn object // already a block\r\n\t}\r\n\treturn new Proxy({\r\n\t\tparsed: object\r\n\t}, binaryMapped)\r\n}\r\nexports.makeBlockFromBuffer = function(buffer, imports) {\r\n\treturn new Proxy({\r\n\t\tbuffer: buffer,\r\n\t\timports: imports\r\n\t}, binaryMapped)\r\n}\r\n\r\nvar binaryMapped = {\r\n\tget: function(target, key) {\r\n\t\tif (specialGetters.hasOwnProperty(key)) {\r\n\t\t\treturn specialGetters[key].call(target)\r\n\t\t}\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\treturn parsed[key]\r\n\t},\r\n\tset: function(target, key, value) {\r\n\t\tif (specialSetters.hasOwnProperty(key)) {\r\n\t\t\tspecialSetters[key].call(target, value)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\t// invalidate the buffer, it is no longer a valid representation\r\n\t\ttarget.buffer = null\r\n\t\tparsed[key] = value\r\n\t\treturn true\r\n\t},\r\n\tgetOwnPropertyDescriptor: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getOwnPropertyDescriptor(parsed, key)\r\n\t},\r\n\thas: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn key in parsed\r\n\t},\r\n\townKeys: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.keys(parsed)\r\n\t}\r\n}\r\n\r\nvar specialGetters = {\r\n\tconstructor: function() {\r\n\t\treturn Block\r\n\t}\r\n}\r\nspecialGetters[bufferSymbol] = function() {\r\n\treturn this.buffer || getSerialized(this)\r\n}\r\nspecialGetters[headerSymbol] = function() {\r\n\tvar buffer = target.buffer\r\n\tvar parser = createParser()\r\n\treturn parseHeader(buffer, parser, 0)\r\n}\r\nspecialGetters[parsedSymbol] = function() {\r\n\treturn this.parsed || getParsed(this)\r\n}\r\nspecialGetters.then = function() {\r\n\t// return undefined, this is not a promise\r\n}\r\nspecialGetters.valueOf = function() {\r\n\treturn valueOf\r\n}\r\nfunction valueOf() {\r\n\treturn this[parsedSymbol]\r\n}\r\n\r\n\r\nvar specialSetters = {\r\n}\r\nspecialSetters[bufferSymbol] = function(buffer) {\r\n\tthis.buffer = buffer\r\n\tthis.parsed = undefined\r\n}\r\n\r\nfunction getParsed(target) {\r\n\tvar parsed = target.parsed\r\n\tif (parsed)\r\n\t\treturn parsed\r\n\t// we check to see if there are multiple blocks that should be deferred into separate blocks\r\n\tvar buffer = target.buffer\r\n\tvar blockParser = createBinaryParser()\r\n\tvar parser = createParser()\r\n\tvar objects = []\r\n\tvar primaryBuffer\r\n\tblockParser.setSource(buffer)\r\n\tvar value = blockParser.readValue()\r\n\tvar referencingPropertyId\r\n\tvar referenceIndex = 1\r\n\t// we check to see if the main entry is a block\r\n\tvar offset = 1\r\n\tvar startSequenceBlock\r\n\tif (value.type === 0 && value.number === 1) { // array\r\n\t\tvalue = blockParser.readValue()\r\n\t\tif (value.type === 3 && value.number === 0) { // null\r\n\t\t\tvalue = blockParser.readValue()\r\n\t\t\toffset = 3\r\n\t\t}\r\n\t}\r\n\tif (value.type === 1 && value.number === 11) { // first byte is open sequence, next two are block property id, then block\r\n\t\t// read enough to read the header parts\r\n\t\tstartSequenceBlock = buffer.slice(0, offset)\r\n\t\tdo {\r\n\t\t\tblockParser.setSource(buffer, offset)\r\n\t\t\tvalue = blockParser.readValue()\r\n\t\t\tvar mainBlock\r\n\t\t\tvar blockLength\r\n\t\t\tif (value.type === 0) {\r\n\t\t\t\tif (value.number >= 6) {\r\n\t\t\t\t\treferencingPropertyId = value.number\r\n\t\t\t\t\tvalue = blockParser.readValue() // read property definition\r\n\t\t\t\t\tif (value.type === 0) {\r\n\t\t\t\t\t\tvalue = blockParser.readValue() // read property key\r\n\t\t\t\t\t\tvalue = blockParser.readValue() // read block length (hopefully)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmainBlock = true\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (value.type === 1) {\r\n\t\t\t\tblockLength = value.number\r\n\t\t\t\tif (blockLength < 16)\r\n\t\t\t\t\tmainBlock = true\r\n\t\t\t\telse\r\n\t\t\t\t\tblockLength -= 16\r\n\t\t\t}\r\n\t\t\tif (!referencingPropertyId || mainBlock) {\r\n\t\t\t\tprimaryBuffer = Buffer.concat([startSequenceBlock, buffer.slice(offset)])\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tvar startOfBlock = blockParser.getOffset()\r\n\t\t\tvar endOfBlock = startOfBlock + blockLength\r\n\t\t\tobjects.push(new Proxy({\r\n\t\t\t\tbuffer: buffer.slice(startOfBlock, endOfBlock)\r\n\t\t\t}, binaryMapped))\r\n\t\t\toffset = endOfBlock\r\n\t\t} while (true)\r\n\t\tparser.assignValues(referencingPropertyId, objects)\r\n\t} else {\r\n\t\tprimaryBuffer = buffer\r\n\t}\r\n\treturn target.parsed = parser.setSource(primaryBuffer.toString(), 0, referenceIndex).read()\r\n}\r\n\r\nfunction getSerialized(target) {\r\n\treturn target.buffer = serialize(target.parsed, {\r\n\t\twithLength: true\r\n\t})\r\n}\r\n\r\nvar readBlockLengthHandler = [\r\n\treturnNull,\r\n\tfunction(length) {\r\n\t\treturn length\r\n\t},\r\n\treturnNull,\r\n\treturnNull\r\n]\r\nfunction returnNull() {\r\n\treturn null\r\n}\r\n\r\nserialize.Block = Block\r\nvar createParser = require('./parse').createParser\r\n","\"use strict\"\r\nfunction Options() {\r\n\tvar classByName = this.classByName = new Map()\r\n\tthis.converterByConstructor = new Map()\r\n\t//writerByConstructor.set(Map, writeMap)\r\n\t//writerByConstructor.set(Set, writeSet)\r\n}\r\nOptions.prototype.addExtension = function(Class, name, options) {\r\n\tif (name && Class.name !== name) {\r\n\t\tClass.name = name\r\n\t}\r\n\tthis.classByName.set(Class.name, (options && options.fromArray) ? options : Class)\r\n\tthis.converterByConstructor.set(Class, (options && options.toArray) ? options : Class)\r\n}\r\nexports.Options = Options\r\n","\"use strict\"\r\nfunction createParser(options) {\r\n\tvar source\r\n\tvar offset = 0\r\n\treturn {\r\n\t\tsetSource: function(buffer, newOffset) {\r\n\t\t\tsource = buffer\r\n\t\t\toffset = newOffset || 0\r\n\t\t},\r\n\t\tgetOffset: function() {\r\n\t\t\treturn offset\r\n\t\t},\r\n\t\treadValue: function() {\r\n\t\t\tvar type, number\r\n\t\t\tvar token = source[offset++]\r\n\t\t\tif (token >= 0x40) { // fast path for one byte with stop bit\r\n\t\t\t\tif (token > 0x4000) { // long-token handling\r\n\t\t\t\t\ttype = (token >>> 12) & 3\r\n\t\t\t\t\tnumber = token & 0xfff\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = (token >>> 4) & 3\r\n\t\t\t\t\tnumber = token & 0xf\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttype = (token >>> 4) & 11 // shift and omit the stop bit (bit 3)\r\n\t\t\t\tnumber = token & 0xf\r\n\t\t\t\ttoken = source[offset++]\r\n\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 10 bit number\r\n\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\ttoken = source[offset++]\r\n\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 16 bit number\r\n\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\ttoken = source[offset++]\r\n\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 22 bit number\r\n\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\ttoken = source[offset++]\r\n\t\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 28 bit number\r\n\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\ttoken = source[offset++]\r\n\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)\r\n\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\ttoken = source[offset++]\r\n\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 40 bit number\r\n\t\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\t\ttoken = source[offset++]\r\n\t\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 46 bit number, we don't go beyond this\r\n\t\t\t\t\t\t\t\t\t\tif (!(token >= 0)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn {\r\n\t\t\t\ttype: type,\r\n\t\t\t\tnumber: number\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nexports.createParser = createParser\r\n","\"use strict\"\r\n\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar SEQUENCE_CODE = 1\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 3\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar METADATA_TYPE = 0\r\nvar ARRAY_TYPE = 1\r\nvar REFERENCING_TYPE = 2\r\nvar NUMBER_TYPE = 3\r\nvar DEFAULT_TYPE = 4\r\nvar EXTENSIONS = 5\r\n\r\nvar NULL = 0\r\nvar UNDEFINED = 1\r\nvar TRUE = 2\r\nvar FALSE = 3\r\n\r\n// referrer types\r\nvar REFERRER_NONE = 0\r\nvar REFERRER_NEXT = 1\r\nvar REFERRER_CHILD = 2\r\nvar REFERRER_PROPERTY = 3\r\n\r\nvar MAX_LENGTH = 1024*1024*16\r\nvar END_SEQUENCE = {}\r\nvar PAUSED = {}\r\n\r\nfunction createParser(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar offset\r\n\tvar source\r\n\tvar property = {}\r\n\tvar isPartial\r\n\tvar lastRead\r\n\tvar properties = []\r\n\tvar classByName = options.classByName || new Map()\r\n\tclassByName.set('Map', readMap)\r\n\tclassByName.set('Set', readSet)\r\n\tclassByName.set('Date', readDate)\r\n\tvar currentBlock\r\n\tvar referrerProperty\r\n\tvar referrerType\r\n\tvar pausedState\r\n\r\n\tfunction pause(state, lastRead) {\r\n\t\tstate.previous = pausedState\r\n\t\tstate.resume = true\r\n\t\tpausedState = state\r\n\t\tif (!isPartial)\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\r\n\t\tif (!parser.onResume) // only if not already defined, otherwise we just want to use the one from the top of the call stack\r\n\t\t\tparser.onResume = function(nextString, isPartialString, rebuildString) {\r\n\t\t\t\t// top of the resume stack\r\n\t\t\t\tvar resumeState = pausedState\r\n\t\t\t\tpausedState = null\r\n\t\t\t\tparser.onResume = null\r\n\t\t\t\t// we slice and add these together to generate an entirely new string\r\n\t\t\t\t// so we don't cause a memory leak with redundant strings that a retained a slice parents\r\n\t\t\t\tif (lastRead < source.length)\r\n\t\t\t\t\tsource = source.slice(lastRead) + nextString\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (rebuildString) // if we have read all of source, we want to slice and re-concatenate to eliminate the slice reference to the parent, we really don't want that retained in memory\r\n\t\t\t\t\t\tsource = nextString.slice(0, 1) + nextString.slice(1)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tsource = nextString\r\n\t\t\t\t}\r\n\t\t\t\tisPartial = isPartialString\r\n\t\t\t\tdisposedChars += lastRead\r\n\t\t\t\toffset = 0\r\n\t\t\t\treturn resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState)\r\n\t\t\t}\r\n\t\treturn state.object\r\n\t}\r\n\r\n\tfunction readSequence(length, thisProperty) {\r\n\t\tvar propertyState = 0\r\n\t\tthisProperty = thisProperty || {}\r\n\t\tvar previousProperty, property, isArray, object, value, i = 0\r\n\t\tif (thisProperty.resume) { // resuming, thisProperty is the resume state.\r\n\t\t\tpreviousProperty = thisProperty.previous\r\n\t\t\tif (previousProperty) {\r\n\t\t\t\t// do the previous/upper stack frame first\r\n\t\t\t\tvar value = previousProperty.reader ? previousProperty.reader(previousProperty) : readSequence(previousProperty.length, previousProperty)\r\n\t\t\t\tvar values = previousProperty.values\r\n\t\t\t\tif (values) {\r\n\t\t\t\t\t// we have an assignment to referencing values that is waiting for pausing to complete\r\n\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t// if still paused, pass on to next pausedState\r\n\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (values.index > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\t\tvalues[values.index++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti = thisProperty.i\r\n\t\t\tobject = thisProperty.object\r\n\t\t\tproperty = thisProperty.property\r\n\t\t\tpreviousProperty = thisProperty.previousProperty\r\n\t\t\tpropertyState = thisProperty.propertyState\r\n\t\t\tthisProperty = thisProperty.thisProperty\r\n\t\t\tisArray = thisProperty.type === 1/*ARRAY_TYPE*/\r\n\t\t} else {\r\n\t\t\tisArray = thisProperty.type === 1/*ARRAY_TYPE*/\r\n\t\t\tobject = thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {} // TODO: we could probably construct a new reader that does this a little faster\r\n\t\t\tif (previousProperty) {\r\n\t\t\t\tproperty = previousProperty.next\r\n\t\t\t} else {\r\n\t\t\t\tproperty = thisProperty.child\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (; i < length;) {\r\n\t\t\tvar type, number\r\n\t\t\tvar lastRead = offset\r\n\t\t\tvar token = source.charCodeAt(offset++)\r\n\t\t\tif (token >= 0x40) { // fast path for one byte with stop bit\r\n\t\t\t\tif (token > 0x4000) { // long-token handling\r\n\t\t\t\t\ttype = (token >>> 12) & 3\r\n\t\t\t\t\tnumber = token & 0xfff\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = (token >>> 4) & 3\r\n\t\t\t\t\tnumber = token & 0xf\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttype = (token >>> 4) & 11 // shift and omit the stop bit (bit 3)\r\n\t\t\t\tnumber = token & 0xf\r\n\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 10 bit number\r\n\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 16 bit number\r\n\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 22 bit number\r\n\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 28 bit number\r\n\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)\r\n\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 40 bit number\r\n\t\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 46 bit number, we don't go beyond this\r\n\t\t\t\t\t\t\t\t\t\tif (!(token >= 0)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (type === 0) { /*PROPERTY_CODE*/\r\n\t\t\t\t// we store the previous property state in token, so we can assign the next one\r\n\t\t\t\ttoken = propertyState\r\n\t\t\t\tif (number < 6) {\r\n\t\t\t\t\tif (number === METADATA_TYPE) {\r\n\t\t\t\t\t\t// always use existing property\r\n\t\t\t\t\t\tif (property.block !== currentBlock)\r\n\t\t\t\t\t\t\tbackupState(property)\r\n\t\t\t\t\t\tpropertyState = 3 // read next value as the metadata parameter\r\n\t\t\t\t\t} else if (number === 5) {\r\n\t\t\t\t\t\tif (property.block !== currentBlock)\r\n\t\t\t\t\t\t\tbackupState(property)\r\n\t\t\t\t\t\tpropertyState = 2 // read next value as the key\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (propertyState === 0) {\r\n\t\t\t\t\t\t\t// creating new property\r\n\t\t\t\t\t\t\tproperty = {\r\n\t\t\t\t\t\t\t\ttype: number,\r\n\t\t\t\t\t\t\t\tkey: null,\r\n\t\t\t\t\t\t\t\tnext: null // preallocating this helps with performance\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (currentBlock) {\r\n\t\t\t\t\t\t\t\tproperty.block = currentBlock\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// else if it is preceeded by a reference type, we just modify it\r\n\t\t\t\t\t\t\tif (property.block !== currentBlock)\r\n\t\t\t\t\t\t\t\tbackupState(property)\r\n\t\t\t\t\t\t\tif (property.values) {\r\n\t\t\t\t\t\t\t\tproperty.values = null // reset this\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (property.fromValue) {\r\n\t\t\t\t\t\t\t\tproperty.fromValue = null // reset this\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tproperty.type = number\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tpropertyState = 2 // read next value as the key\r\n\t\t\t\t\t\tif (number === 2/*REFERENCING_TYPE*/) {\r\n\t\t\t\t\t\t\tproperty.values = []\r\n\t\t\t\t\t\t} else if (number === ARRAY_TYPE) {\r\n\t\t\t\t\t\t\tproperty.child = {\r\n\t\t\t\t\t\t\t\ttype: DEFAULT_TYPE,\r\n\t\t\t\t\t\t\t\tkey: null,\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (propertyState === 0) {\r\n\t\t\t\t\t\tproperty = properties[number]\r\n\t\t\t\t\t\tif (!property) {\r\n\t\t\t\t\t\t\tproperty = properties[number] = {\r\n\t\t\t\t\t\t\t\tindex: number,\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (currentBlock) {\r\n\t\t\t\t\t\t\t\t(currentBlock.indices || (currentBlock.indices = [])).push(number)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (properties[number]) {\r\n\t\t\t\t\t\tif (property.block !== currentBlock)\r\n\t\t\t\t\t\t\tbackupState(property)\r\n\r\n\t\t\t\t\t\tproperty.values = properties[number].values\r\n\t\t\t\t\t\t// property.type = properties[number].type // do we need to do this?\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tpropertyState = 1\r\n\t\t\t\t}\r\n\t\t\t\tif (token === 0) {\r\n\t\t\t\t\tif (previousProperty) {\r\n\t\t\t\t\t\tif (previousProperty.block !== currentBlock)\r\n\t\t\t\t\t\t\tbackupState(previousProperty)\r\n\t\t\t\t\t\tpreviousProperty.next = property\r\n\t\t\t\t\t} else { // in array mode, will never have a previousProperty defined\r\n\t\t\t\t\t\tif (thisProperty.block !== currentBlock)\r\n\t\t\t\t\t\t\tbackupState(thisProperty)\r\n\t\t\t\t\t\tthisProperty.child = property\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (propertyState < 2 && property && property.type === 2/*REFERENCING_TYPE*/) {\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (currentBlock && property.block !== currentBlock && !(type === 3 && number >= 4)) {\r\n\t\t\t\t\tproperty.values = values.slice(0) // copy this\r\n\t\t\t\t\tbackupState(property)\r\n\t\t\t\t\tproperty.values = values\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvalues = null\r\n\t\t\t}\r\n\t\t\tif (type === 2 /*STRING_CODE*/) {\r\n\t\t\t\tvalue = source.slice(offset, offset += number)\r\n\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t}, lastRead)\r\n\t\t\t\t}\r\n\t\t\t\tif (propertyState < 2) {\r\n\t\t\t\t\tif (property.type === 3/*NUMBER_TYPE*/) {\r\n\t\t\t\t\t\tvalue = +value\r\n\t\t\t\t\t} else if (values) {\r\n\t\t\t\t\t\tif (values.index > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\t\tvalues[values.index++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (type === 3) { /*NUMBER_CODE*/\r\n\t\t\t\tif (number >= 4) {\r\n\t\t\t\t\tif (values) {\r\n\t\t\t\t\t\tvalue = values[number - 4]\r\n\t\t\t\t\t\tif (value === undefined && !((number - 4) in values)) {\r\n\t\t\t\t\t\t\tvalue = forwardReference(number, values) // forward referencing\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = number - 4\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (number === 0) {\r\n\t\t\t\t\t\tvalue = null\r\n\t\t\t\t\t} else if (number === 2) {\r\n\t\t\t\t\t\tvalue = true\r\n\t\t\t\t\t} else if (number === 3) {\r\n\t\t\t\t\t\tvalue = false\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalue = undefined\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (values) {\r\n\t\t\t\t\t\tif (values.index > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\t\tvalues[values.index++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else { /*SEQUENCE_CODE*/\r\n\t\t\t\tif (number === 13) { // end sequence\r\n\t\t\t\t\treturn object\r\n\t\t\t\t}\r\n\t\t\t\tif (number > 10) {\r\n\t\t\t\t\tif (number === 11) {\r\n\t\t\t\t\t\tvalue = readSequence(MAX_LENGTH, property)\r\n\t\t\t\t\t} else if (number === 14 || number < 16000000) {\r\n\t\t\t\t\t\tvalue = readAsBlock(property)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t}\r\n\t\t\t\tif (pausedState) {\r\n\t\t\t\t\tif (value === undefined) { // or a PAUSED object\r\n\t\t\t\t\t\tpausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here\r\n\t\t\t\t\t\tparser.onResume = null\r\n\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// need to assign the values *after* the completion of the sequence if it is a forward reference\r\n\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (values) {\r\n\t\t\t\t\tif (values.index > -1) {\r\n\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\tvalues[values.index++] = value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (propertyState > 0) {\r\n\t\t\t\t// 0: normal\r\n\t\t\t\tif (propertyState === 1) { // 1: property reference\r\n\t\t\t\t\tpropertyState = 0\r\n\t\t\t\t}\r\n\t\t\t\telse if (propertyState === 2) { // property key\r\n\t\t\t\t\tpropertyState = 1\r\n\t\t\t\t\tproperty.key = value\r\n\t\t\t\t\tcontinue // read next value as the property value\r\n\t\t\t\t} else { // 3: metadata paramater\r\n\t\t\t\t\tpropertyState = 1\r\n\t\t\t\t\tvar extendedType = classByName.get(value)\r\n\t\t\t\t\tif (extendedType) {\r\n\t\t\t\t\t\tif (extendedType.fromValue) {\r\n\t\t\t\t\t\t\tproperty.fromValue = extendedType.fromValue\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tproperty.constructs = extendedType\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (options.errorOnUnknownClass) {\r\n\t\t\t\t\t\tthrow new Error('Attempt to deserialize to unknown class ' + parameter)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t//\treadingProperty.readValue = readAsDefault\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue // read next value as the property value\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (property) {\r\n\t\t\t\tif (property.fromValue) {\r\n\t\t\t\t\tvalue = property.fromValue(value)\r\n\t\t\t\t}\r\n\t\t\t\tif (isArray) {\r\n\t\t\t\t\tif (property.key === null) {\r\n\t\t\t\t\t\tobject.push(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if (property.key !== undefined && value !== undefined) {\r\n\t\t\t\t\t\tobject[property.key] = value\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n/*\t\t\t\t\tif (!property) {\r\n\t\t\t\t\t\tthrow new Error('No property defined for property in slot ' +  ' value: ' + value)\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\tif (value !== undefined) { // TODO: declare undefined locally?\r\n\t\t\t\t\t\tvar key = property.key\r\n\t\t\t\t\t\tif (key)\r\n\t\t\t\t\t\t\tobject[key] = value\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\tif (key === null) {\r\n\t\t\t\t\t\t\t\t// for objects null indicates replacing the parent object\r\n\t\t\t\t\t\t\t\tobject[0] = value\r\n\t\t\t\t\t\t\t} else if (key !== undefined) {\r\n\t\t\t\t\t\t\t\t// could be '', 0, or false, all valid keys, only undefined should be skipped\r\n\t\t\t\t\t\t\t\tobject[key] = value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tpreviousProperty = property\r\n\t\t\t\t\tproperty = previousProperty.next\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\r\n\tfunction backupState(property) {\r\n\t\tproperty.block = currentBlock\r\n\t\tvar backup = {\r\n\t\t\toriginal: property,\r\n\t\t\ttype: property.type,\r\n\t\t\tfirst: property.first,\r\n\t\t\tchild: property.child,\r\n\t\t\tfromValue: property.fromValue,\r\n\t\t\tvalues: property.values,\r\n\t\t};\r\n\t\t(currentBlock.properties || (currentBlock.properties = [])).push(backup)\r\n\t}\r\n\r\n\tvar currentBlock\r\n\r\n\tfunction readAsBlock(property) {\r\n\t\tvar value\r\n\t\tif (property.resume) {\r\n\t\t\tparentBlock = property.parentBlock\r\n\t\t\tvar previous = property.previous\r\n\t\t\tvalue = readSequence(previous.length, previous)\r\n\t\t\t// once we get the value, we don't know which point in the stack could still be resolving\r\n\t\t\tvalue = property.object || (previous.thisProperty.isBlock ? value[0] : value)\r\n\t\t} else {\r\n\t\t\tvar parentBlock = currentBlock\r\n\t\t\tcurrentBlock = {}\r\n\t\t\tvalue = readSequence(1, {\r\n\t\t\t\tblock: currentBlock,\r\n\t\t\t\tisBlock: true,\r\n\t\t\t\tchild: {\r\n\t\t\t\t\ttype: 4,\r\n\t\t\t\t\tblock: currentBlock,\r\n\t\t\t\t\tkey: null\r\n\t\t\t\t}\r\n\t\t\t})[0]\r\n\t\t}\r\n\t\tif (pausedState && value !== undefined) {\r\n\t\t\t// restore state of property\r\n\t\t\tif (!property.resume) {\r\n\r\n\t\t\t}\r\n\t\t\tpause({\r\n\t\t\t\treader: readAsBlock,\r\n\t\t\t\tobject: value,\r\n\t\t\t\tproperty: property,\r\n\t\t\t\tparentBlock: parentBlock\r\n\t\t\t})\r\n\t\t} else {\r\n\t\t\t// restore state from beginning of block\r\n\t\t\tvar backups = currentBlock.properties\r\n\t\t\tif (backups) {\r\n\t\t\t\tfor (var i = 0, l = backups.length; i < l; i++) {\r\n\t\t\t\t\tvar backup = backups[i]\r\n\t\t\t\t\tvar original = backup.original\r\n\t\t\t\t\toriginal.type = backup.type\r\n\t\t\t\t\toriginal.values = backup.values\r\n\t\t\t\t\toriginal.fromValue = backup.fromValue\r\n\t\t\t\t\toriginal.next = backup.next\r\n\t\t\t\t\toriginal.child = backup.child\r\n\t\t\t\t\toriginal.block = parentBlock\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar indices = currentBlock.indices\r\n\t\t\tif (indices) {\r\n\t\t\t\tfor (var i = 0, l = indices.length; i < l; i++) {\r\n\t\t\t\t\tproperties[indices[i]] = null\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcurrentBlock = parentBlock\r\n\t\t}\r\n\t\treturn value\r\n\t}\r\n\r\n\tfunction forwardReference(number, values) {\r\n\t\tvar object = {}\r\n\t\tvalues.index = values.index === undefined ? values.length : values.index // make sure we are using index property for maintaining location, since length will change with the property definition\r\n\t\tObject.defineProperty(values, number - 4, {\r\n\t\t\tset: function(value) {\r\n\t\t\t\tObject.assign(object, value)\r\n\t\t\t\tif (value && value.constructor === Array) {\r\n\t\t\t\t\tobject.length = value.length\r\n\t\t\t\t\tObject.setPrototypeOf(object, Object.getPrototypeOf(value)) // do our best to make it array like\r\n\t\t\t\t}\r\n\t\t\t\tObject.defineProperty(values, number - 4, {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\tconfigurable: true\r\n\t\t\t\t})\r\n\t\t\t\treturn value\r\n\t\t\t},\r\n\t\t\tget: function(value) {\r\n\t\t\t\treturn object\r\n\t\t\t},\r\n\t\t\tconfigurable: true\r\n\t\t})\r\n\t\treturn object\r\n\t}\r\n\r\n\tfunction unknownType(number) {\r\n\t\tthrow new Error('Unknown type ' + number)\r\n\t}\r\n\r\n\tvar unfulfilledReferences = 0\r\n\tvar disposedChars = 0\r\n\tfunction read(result) {\r\n\t\treturn readSequence(1, {\r\n\t\t\tchild: {\r\n\t\t\t\ttype: 4,\r\n\t\t\t\tkey: null\r\n\t\t\t}\r\n\t\t})[0]\r\n\t}\r\n\r\n\tvar parser = {\r\n\t\tsetSource: function(string, startOffset, isPartialString) {\r\n\t\t\tsource = string\r\n\t\t\toffset = startOffset || 0\r\n\t\t\tdisposedChars = 0\r\n\t\t\tisPartial = isPartialString\r\n\t\t\treturn this\r\n\t\t},\r\n\t\thasMoreData: function() {\r\n\t\t\treturn source.length > offset\r\n\t\t},\r\n\t\tisPaused: function() {\r\n\t\t\treturn pausedState\r\n\t\t},\r\n\t\thasUnfulfilledReferences: function() {\r\n\t\t\treturn unfulfilledReferences > 0\r\n\t\t},\r\n\t\tgetOffset: function() {\r\n\t\t\treturn offset + disposedChars\r\n\t\t},\r\n\t\tread: read,\r\n\t\tassignValues: function(propertyId, values) {\r\n\t\t\tproperties[propertyId] = {\r\n\t\t\t\ttype: 2,\r\n\t\t\t\tvalues: values\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn parser\r\n}\r\nexports.parse = function(stringOrBuffer, options) {\r\n\tvar source\r\n\tif (typeof stringOrBuffer === 'string') {\r\n\t\tsource = stringOrBuffer\r\n\t} else if (stringOrBuffer && stringOrBuffer.toString) {\r\n\t\tsource = stringOrBuffer.toString(options && options.encoding || 'utf8')\r\n\t} else { // whatever (undefined or null or whatever), just return it\r\n\t\treturn stringOrBuffer\r\n\t}\r\n\tvar parser = createParser(options).setSource(source)\r\n\treturn parser.read()\r\n}\r\nexports.parseLazy = function(buffer, parser) {\r\n\tif ((buffer[0] & 0x30) === 0x10) {\r\n\t\treturn makeBlockFromBuffer(buffer, parser || createParser())\r\n\t} else if (parser) {\r\n\t\treturn parser.setSource(buffer.toString()).read()\r\n\t} else {\r\n\t\treturn exports.parse(buffer)\r\n\t}\r\n}\r\nexports.createParser = createParser\r\nvar makeBlockFromBuffer = require('./Block').makeBlockFromBuffer\r\nvar bufferSymbol = require('./Block').bufferSymbol\r\n\r\nvar readMap = {\r\n\tfromValue: function(entries) {\r\n\t\tvar map = new Map()\r\n\t\tfor (var i = 0, l = entries.length; i < l; i++) {\r\n\t\t\tvar entry = entries[i]\r\n\t\t\tmap.set(entry.key, entry.value)\r\n\t\t}\r\n\t\treturn map\r\n\t}\r\n}\r\nvar readSet = {\r\n\tfromValue: function(values) {\r\n\t\tvar set = new Set(values)\r\n\t\tif (set.size === 0 && values.length > 0) {\r\n\t\t\tfor (var i = 0, l = values.length; i < l; i++) {\r\n\t\t\t\tset.add(values[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn set\r\n\t}\r\n}\r\nvar readDate = {\r\n\tfromValue: function(time) {\r\n\t\treturn new Date(time)\r\n\t}\r\n}\r\n\r\n","\"use strict\"\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar SEQUENCE_CODE = 1\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 3\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar METADATA_TYPE = 0\r\nvar ARRAY_TYPE = 1\r\nvar REFERENCING_TYPE = 2\r\nvar NUMBER_TYPE = 3\r\nvar DEFAULT_TYPE = 4\r\nvar CONTINUED_REFERENCING_TYPE = 5\r\n\r\nvar BLOCK_SUB_CODE = 14\r\nvar BLOCK_LENGTH_SUB_CODE = 15\r\n\r\nvar NULL = 0\r\nvar UNDEFINED = 1\r\nvar TRUE = 2\r\nvar FALSE = 3\r\n\r\nfunction createSerializer(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar maxReferenceableStringLength = options.maxReferenceableStringLength || 2400\r\n\tvar extendedTypes = options.converterByConstructor\r\n\tif (!extendedTypes) {\r\n\t\textendedTypes = new Map()\r\n\t}\r\n\textendedTypes.set(Map, {\r\n\t\tname: 'Map',\r\n\t\ttoValue: writeMap\r\n\t})\r\n\textendedTypes.set(Set, {\r\n\t\tname: 'Set',\r\n\t\ttoValue: writeSet\r\n\t})\r\n\textendedTypes.set(Date, {\r\n\t\tname: 'Date',\r\n\t\ttoValue: writeDate\r\n\t})\r\n\tvar charEncoder = (typeof global != 'undefined' && global.Buffer) ? exports.nodeCharEncoder(options) : browserCharEncoder(options)\r\n\tvar writeString = charEncoder.writeString\r\n\tvar writeToken = charEncoder.writeToken\r\n\tvar startSequence = charEncoder.startSequence\r\n\tvar endSequence = charEncoder.endSequence\r\n\tvar writeBuffer = charEncoder.writeBuffer\r\n\tvar pendingEncodings = []\r\n\tvar properties = new Map()\r\n\tvar nextBlockId = 0\r\n\tvar nextPropertyIndex = 8\r\n\tvar property = { index: 0 } // default root property\r\n\tvar rootProperty = property\r\n\tif (options.useImport) {\r\n\t\t//options.useImport\r\n\t}\r\n\r\n\t// write a rudimentary array\r\n\tfunction writeArray(array) {\r\n\t\tvar length = array.length\r\n\t\tvar arrayProperty = property\r\n\t\tif (length > 10) {\r\n\t\t\twriteToken(SEQUENCE_CODE, 11) // start sequence [\r\n\t\t} else {\r\n\t\t\twriteToken(SEQUENCE_CODE, length) // write out the header token\r\n\t\t}\r\n\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\tproperty.writeValue(array[i])\r\n\t\t}\r\n\t\tif (length > 10) {\r\n\t\t\twriteToken(SEQUENCE_CODE, 13) // end sequence\r\n\t\t}\r\n\t\tproperty = arrayProperty\r\n\t}\r\n\t// write a rudimentary number\r\n\tfunction writeNumber(number) {\r\n\t\twriteToken(NUMBER_CODE, number)\r\n\t}\r\n\t// write a rudimentary string\r\n\tfunction writeInlineString(string) {\r\n\t\twriteToken(STRING_CODE, string.length)\r\n\t\twriteString(string)\r\n\t}\r\n\r\n\t// writing any value in referencing serialization type mode\r\n\tfunction writeAsReferencing(value) {\r\n\t\tvar values = property.values\r\n\t\tif (values) {\r\n\t\t\tvar reference = values.indexOf(value)\r\n\t\t\tif (reference > -1) {\r\n\t\t\t\treturn writeNumber(reference + 4)\r\n\t\t\t} else {\r\n\t\t\t\tvar index = values.length\r\n\t\t\t\tif (index < 12)\r\n\t\t\t\t\tvalues[index] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar type = typeof value\r\n\t\tif (type === 'string') {\r\n\t\t\twriteInlineString(value)\r\n\t\t} else {\r\n\t\t\twriteAsDefault(value)\r\n\t\t}\r\n\t}\r\n\r\n\t// writing any value in number serialization type mode\r\n\tfunction writeAsNumber(number) {\r\n\t\tvar type = typeof number\r\n\t\tif (type === 'number') {\r\n\t\t\tif (number >>> 0 === number || (number > 0 && number < 0x400000000000 && number % 1 === 0)) {\r\n\t\t\t\t// 46 bit unsigned integer\r\n\t\t\t\twriteToken(NUMBER_CODE, number + 4)\r\n\t\t\t} else {\r\n\t\t\t\t// decimal number serialized as a string\r\n\t\t\t\tvar asString = number.toString()\r\n\t\t\t\twriteInlineString(asString)\r\n\t\t\t}\r\n\t\t} else if (type === 'boolean') {\r\n\t\t\twriteToken(NUMBER_CODE, number ? TRUE : FALSE)\r\n\t\t} else if (type === 'object' && number && number.constructor === Array) {\r\n\t\t\twriteArray(number)\r\n\t\t} else {\r\n\t\t\twriteTypedValue(number)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedValue(value) {\r\n\t\tif (value === null)\r\n\t\t\twriteToken(NUMBER_CODE, NULL)\r\n\t\telse if (value === false)\r\n\t\t\twriteToken(NUMBER_CODE, FALSE)\r\n\t\telse if (value === true)\r\n\t\t\twriteToken(NUMBER_CODE, TRUE)\r\n\t\telse if (value === undefined)\r\n\t\t\twriteToken(NUMBER_CODE, UNDEFINED)\r\n\t\telse {\r\n\t\t\twriteTypedNonConstant(value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedNonConstant(value) {\r\n\t\tvar type = typeof value\r\n\t\tvar extendedType\r\n\t\tif (type === 'object') {\r\n\t\t\tif (value) {\r\n\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t// leave type as is\r\n\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\ttype = 'array'\r\n\t\t\t\t} else {\r\n\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property.type === type) {\r\n\t\t\t\t\t\t\t// if we are the right type after doing the conversion, go back to the original property to serialize\r\n\t\t\t\t\t\t\tif (property.extendedType !== extendedType) {\r\n\t\t\t\t\t\t\t\tproperty.extendedType = extendedType\r\n\t\t\t\t\t\t\t\twriteToken(PROPERTY_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn property.writeValue(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t} else { // null\r\n\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t}\r\n\t\t} else if (type === 'boolean') {\r\n\t\t\ttype = 'undefined'\r\n\t\t} else if (type === 'function') {\r\n\t\t\tvalue = value.toString()\r\n\t\t\ttype = 'string'\r\n\t\t}\r\n\t\twriteProperty(value, null, type, extendedType).writeValue(value)\r\n\t}\r\n\r\n\tfunction writeOnlyNull() {\r\n\t\twriteToken(NUMBER_CODE, NULL)\r\n\t}\r\n\r\n\t// writing any value in default serialization type mode\r\n\tfunction writeAsDefault(value, parentProperty) {\r\n\t\tvar type = typeof value\r\n\t\tif (type === 'object') {\r\n\t\t\tif (!value) {\r\n\t\t\t\treturn writeToken(NUMBER_CODE, NULL)\r\n\t\t\t}\r\n\t\t\t// else continue with the object code\r\n\t\t} else if (type === 'string') {\r\n\t\t\tif (parentProperty) {\r\n\t\t\t\treturn (parentProperty.child = writeProperty(value, null, 'string')).writeValue(value)\r\n\t\t\t}\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\t// 46 bit unsigned integer\r\n\t\t\treturn writeToken(NUMBER_CODE, value + 4)\r\n\t\t} else {\r\n\t\t\treturn writeTypedValue(value)\r\n\t\t}\r\n\t\tvar object = value\r\n\t\tvar constructor = object.constructor\r\n\t\tvar notPlainObject\r\n\t\tif (constructor === Object) {\r\n\t\t\tnotPlainObject = false\r\n\t\t} else if (constructor === Array) {\r\n\t\t\treturn writeProperty(value, null, 'array').writeValue(value, parentProperty)\r\n\t\t} else {\r\n\t\t\tif (object.then) {\r\n\t\t\t\treturn writeProperty(value, null, 'block').writeValue(value)\r\n\t\t\t}\r\n\t\t\tif (constructor === serialize.Block) {\r\n\t\t\t\treturn writeProperty(value, null, 'block').writeValue(value)\r\n\t\t\t}\r\n\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\tif (extendedType) {\r\n\t\t\t\tif (extendedType.toValue) {\r\n\t\t\t\t\treturn writeTypedValue(object)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\textendedTypes.set(constructor, extendedType = {\r\n\t\t\t\t\tname: constructor.name\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (property.constructs !== constructor) {\r\n\t\t\t\twriteToken(PROPERTY_CODE, METADATA_TYPE)\r\n\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\tproperty.constructs = constructor\r\n\t\t\t}\r\n\t\t\tif (typeof Symbol !== 'undefined' && object[Symbol.iterator]) {\r\n\t\t\t\twriteProperty(value, null, 'array')\r\n\t\t\t\twriteAsIterable(object)\r\n\t\t\t}\r\n\t\t\tnotPlainObject = true\r\n\t\t}\r\n\t\tvar thisProperty = property\r\n\t\tproperty = thisProperty.first\r\n\t\tstartSequence()\r\n\t\tvar i = 0\r\n\t\tfor (var key in object) {\r\n\t\t\tif (notPlainObject && !object.hasOwnProperty(key))\r\n\t\t\t\tcontinue\r\n\t\t\tvar value = object[key]\r\n\t\t\ttype = typeof value\r\n\t\t\tvar constructor\r\n\t\t\tvar extendedType = false\r\n\t\t\tif (type === 'object') {\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tconstructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t} else if (constructor === serialize.Block) {\r\n\t\t\t\t\t\ttype = 'block'\r\n\t\t\t\t\t} else if (value.then) {\r\n\t\t\t\t\t\ttype = 'block'\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // null\r\n\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t\t}\r\n\t\t\t} else if (type === 'boolean') {\r\n\t\t\t\ttype = 'undefined'\r\n\t\t\t}\r\n\t\t\tif (!property || property.key !== key ||\r\n\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && value !== null) ||\r\n\t\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\tproperty = properties.get(key)\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\tif (property.index) {\r\n\t\t\t\t\t\tif (property.type === type && (!extendedType || property.extendedType === constructor)) { // right type, we can just reference the property\r\n\t\t\t\t\t\t\twriteToken(PROPERTY_CODE, property.index)\r\n\t\t\t\t\t\t} else if (property[type]) {\r\n\t\t\t\t\t\t\tproperty = property[type]\r\n\t\t\t\t\t\t\twriteToken(PROPERTY_CODE, property.index)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tproperty = property[type] = writeProperty(value, key, type, extendedType, nextPropertyIndex++)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tproperty = writeProperty(value, key, type, extendedType, nextPropertyIndex++)\r\n\t\t\t\t\t\tproperties.set(key, property)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperty = writeProperty(value, key, type, extendedType)\r\n\t\t\t\t\tproperties.set(key, true)\r\n\t\t\t\t}\r\n\t\t\t\tif (previousProperty)\r\n\t\t\t\t\tpreviousProperty.next = property\r\n\t\t\t\telse\r\n\t\t\t\t\tthisProperty.first = property\r\n\t\t\t\t/*if (needsStateRecorded) {\r\n\t\t\t\t\tif (property.currentBlock !== currentBlock) {\r\n\t\t\t\t\t\tstructuresToRestore.push(property, structure.slice(0))\r\n\t\t\t\t\t\tproperty.currentBlock = currentBlock\r\n\t\t\t\t\t\tneedsStateRecorded = false\r\n\t\t\t\t\t}\r\n\t\t\t\t}*/\r\n\t\t\t\t// once it is written, update our entries\r\n\t\t\t}\r\n\t\t\tproperty.writeValue(value)\r\n\t\t\tvar previousProperty = property\r\n\t\t\tproperty = previousProperty.next\r\n\t\t\ti++\r\n\t\t}\r\n\t\tif (parentProperty === rootProperty && pendingEncodings.length > 0) {\r\n\t\t\t// note that we don't change back to the object's property, as the pending encodings should use relative references relative to the last property\r\n\t\t\tproperty = previousProperty\r\n\t\t\tserializer.rootBuffer = Buffer.from([]) // indicate that we need to finish with an end sequence token\r\n\t\t\tserializer.startSequenceLength = 1\r\n\t\t} else {\r\n\t\t\tproperty = thisProperty\r\n\t\t\tendSequence(i)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeProperty(value, key, type, extendedType, index) {\r\n\t\tif (type === 'block') {\r\n\t\t\tif (!blockProperty) {\r\n\t\t\t\tblockProperty = {\r\n\t\t\t\t\tindex: 7,\r\n\t\t\t\t\ttype: CONTINUED_REFERENCING_TYPE,\r\n\t\t\t\t\twriteValue: writeAsBlock,\r\n\t\t\t\t\tvalues: []\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twriteToken(PROPERTY_CODE, 7)\r\n\t\t\tif (nextBlockId === 0 && options.outlet) {\r\n\t\t\t\twriteToken(PROPERTY_CODE, REFERENCING_TYPE)\r\n\t\t\t} else {\r\n\t\t\t\twriteToken(PROPERTY_CODE, CONTINUED_REFERENCING_TYPE)\r\n\t\t\t}\r\n\t\t\tproperty = blockProperty\r\n\t\t\tproperty.key = key\r\n\t\t\tproperty.writeValue = writeAsBlock\r\n\t\t\tif (typeof key === 'string') {\r\n\t\t\t\twriteInlineString(key)\r\n\t\t\t} else {\r\n\t\t\t\twriteAsDefault(key)\r\n\t\t\t}\r\n\t\t\treturn property\r\n\t\t}\r\n\t\tproperty = {\r\n\t\t\ttype: type,\r\n\t\t\tkey: key\r\n\t\t}\r\n\t\tif (index) {\r\n\t\t\twriteToken(PROPERTY_CODE, index)\r\n\t\t\tproperty.index = index\r\n\t\t}\r\n\t\tif (type === 'string') {\r\n\t\t\twriteToken(PROPERTY_CODE, REFERENCING_TYPE)\r\n\t\t\tproperty.values = []\r\n\t\t\tproperty.writeValue = writeAsReferencing\r\n\t\t} else if (type === 'number') {\r\n\t\t\twriteToken(PROPERTY_CODE, NUMBER_TYPE)\r\n\t\t\tproperty.writeValue = writeAsNumber\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteToken(PROPERTY_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.writeValue = writeAsDefault\r\n\t\t} else if (type === 'array') {\r\n\t\t\twriteToken(PROPERTY_CODE, ARRAY_TYPE)\r\n\t\t\tproperty.child = {\r\n\t\t\t\ttype: 'object',\r\n\t\t\t\tkey: null,\r\n\t\t\t\tindex: property.index,\r\n\t\t\t\twriteValue: writeAsDefault\r\n\t\t\t}\r\n\t\t\tproperty.writeValue = writeAsArray\r\n\t\t} else if (type === 'boolean' || type === 'undefined') {\r\n\t\t\twriteToken(PROPERTY_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.writeValue = writeAsDefault\r\n\t\t} else {\r\n\t\t\twriteToken(PROPERTY_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.writeValue = writeOnlyNull\r\n\t\t\tconsole.error('Unable to write value of type ' + type)\r\n\t\t}\r\n\r\n\t\tif (typeof key === 'string') {\r\n\t\t\twriteInlineString(key)\r\n\t\t} else {\r\n\t\t\twriteAsDefault(key)\r\n\t\t}\r\n\t\tif (extendedType) {\r\n\t\t\tproperty.extendedType = extendedType\r\n\t\t\twriteToken(PROPERTY_CODE, METADATA_TYPE)\r\n\t\t\twriteInlineString(extendedType.name)\r\n\t\t}\r\n\t\treturn property\r\n\t}\r\n\r\n\tfunction writeAsBlock(value) {\r\n\t\t// once we enter the block property, we must exit to serialize any other type, or we mess up the reference numbers\r\n\t\tif (value && (value.constructor === serialize.Block || value.then)) {\r\n\t\t\treturn writeBlockReference(value)\r\n\t\t}\r\n\t\treturn writeTypedValue(value)\r\n\t}\r\n\r\n\tfunction writeAsIterable(iterable) {\r\n\t\twriteToken(SEQUENCE_CODE, 11)\r\n\t\tvar iterator = iterable[Symbol.iterator]()\r\n\t\tvar arrayProperty = property\r\n\t\tproperty = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property\r\n\t\t// write out the elements\r\n\t\tvar result\r\n\t\twhile(!(result = iterator.next()).done) {\r\n\t\t\tproperty.writeValue(result.value, arrayProperty)\r\n\t\t}\r\n\t\tif (property !== arrayProperty.child) {\r\n\t\t\t// TODO: This really needs to happen immediately when a property changes, to match the parsing behavior\r\n\t\t\tarrayProperty.child = property\r\n\t\t}\r\n\t\tproperty = arrayProperty // restore current property\r\n\t\twriteToken(SEQUENCE_CODE, 13) // end sequence\r\n\t}\r\n\r\n\tfunction writeAsArray(array, parentProperty) {\r\n\t\tif (array && array.constructor === Array) { // check to make sure it is an array\r\n\t\t\tvar length = array.length\r\n\t\t\tvar needsClosing\r\n\t\t\tif (length > 10 || parentProperty === rootProperty) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, 11) // start sequence [\r\n\t\t\t\tneedsClosing = true\r\n\t\t\t} else {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, length) // write out the header token\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property\r\n\t\t\t// write out the elements\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tproperty.writeValue(array[i], arrayProperty)\r\n\t\t\t}\r\n\t\t\tif (property !== arrayProperty.child) {\r\n\t\t\t\t// TODO: This really needs to happen immediately when a property changes, to match the parsing behavior\r\n\t\t\t\tarrayProperty.child = property\r\n\t\t\t}\r\n\t\t\tif (needsClosing) {\r\n\t\t\t\tif (parentProperty === rootProperty && pendingEncodings.length > 0) {\r\n\t\t\t\t\tserializer.rootBuffer = Buffer.from([]) // indicate that we need to finish with an end sequence token\r\n\t\t\t\t\tserializer.startSequenceLength = 3\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\twriteToken(SEQUENCE_CODE, 13) // end sequence\r\n\t\t\t}\r\n\t\t\tproperty = arrayProperty // restore current property\r\n\t\t} else { // bail to default mode behavior\r\n\t\t\twriteTypedValue(array)\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tfunction writeBlock(value) {\r\n\t\tvar parentProperties = properties\r\n\t\tvar parentProperty = property\r\n\t\tvar parentBlockProperty = blockProperty\r\n\r\n\t\tvar parentPropertyIndex = nextPropertyIndex\r\n\t\tvar parentNextBlockId = nextBlockId\r\n\t\tvar parentRootProperty = rootProperty\r\n\t\tnextPropertyIndex = 8\r\n\t\tproperties = new Map()\r\n\t\trootProperty = property = { index: 0 } // new root property\r\n\t\tblockProperty = null\r\n\t\tnextBlockId = 0\r\n\t\twriteToken(SEQUENCE_CODE, BLOCK_SUB_CODE)\r\n\t\twriteBuffer(serialize(value))\r\n\t\tproperties = parentProperties\r\n\t\tnextPropertyIndex = parentPropertyIndex\r\n\t\tproperty = parentProperty\r\n\t\trootProperty = parentRootProperty\r\n\t\tnextBlockId = parentNextBlockId\r\n\t\tblockProperty = parentBlockProperty\r\n\t}\r\n\r\n\tfunction getRelativeReference(id) {\r\n\t\tvar relativeIndex = id - property.index\r\n\t\treturn relativeIndex >= 0 ? (relativeIndex << 1) + 8 : ((-relativeIndex << 1) + 7)\r\n\t}\r\n\r\n\tfunction writePromise(promise) { // in object mode\r\n\t\tvar id = nextBlockId++\r\n\t\tif (id === 0 && options.outlet) {\r\n\t\t\twriteToken(PROPERTY_CODE, 7)\r\n\t\t\twriteToken(PROPERTY_CODE, REFERENCING_TYPE)\r\n\t\t\twriteToken(NUMBER_CODE, UNDEFINED)\r\n\t\t\twriteToken(NUMBER_CODE, UNDEFINED)\r\n\t\t}\r\n\t\twriteToken(PROPERTY_CODE, 7)\r\n\t\twriteToken(NUMBER_CODE, id + 4) // should be in object mode\r\n\t\tvar lazyPromise = {\r\n\t\t\tthen: function(callback) {\r\n\t\t\t\treturn promise.then(function(value) {\r\n/*\t\t\t\t\tif (inLazyDocument) {\r\n\t\t\t\t\t\tvar valueBuffer = writeOpen(value)\r\n\t\t\t\t\t\twriteToken(0, 13)\r\n\t\t\t\t\t\twriteFixed(length)\r\n\t\t\t\t\t\twriteToken(0, 14)\r\n\t\t\t\t\t\twriteFixed(id)\r\n\t\t\t\t\t\twriteBuffer(valueBuffer)\r\n\t\t\t\t\t} else\r\n\t\t\t\t\t*/\r\n\r\n\t\t\t\t\tvar startOffset = charEncoder.getOffset()\r\n\t\t\t\t\tvar buffer = value && value[bufferSymbol]\r\n\t\t\t\t\tif (id === 1 && !options.outlet) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, 7)\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, REFERENCING_TYPE)\r\n\t\t\t\t\t\twriteToken(NUMBER_CODE, UNDEFINED)\r\n\t\t\t\t\t\twriteToken(NUMBER_CODE, UNDEFINED)\r\n\t\t\t\t\t}\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, 7)\r\n\t\t\t\t\tif (buffer) { // block array\r\n\t\t\t\t\t\twriteToken(SEQUENCE_CODE, buffer.length + 16) // indicate it is a block\r\n\t\t\t\t\t\twriteBuffer(buffer)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteBlock(value) // write it as a block\r\n\t\t\t\t\t}\r\n\t\t\t\t}, function(error) {\r\n\t\t\t\t\twriteToken(SEQUENCE_CODE, id)\r\n\t\t\t\t\twriteBlock({ error: error.message }) // write it as a block\r\n\t\t\t\t}).then(callback)\r\n\t\t\t}\r\n\t\t}\r\n\t\tpendingEncodings.push(lazyPromise)\r\n\t}\r\n\r\n\tvar blockProperty\r\n\r\n\r\n\tfunction writeBlockReference(block, writer) {\r\n\t\tvar id = nextBlockId++\r\n\t\tif (!blockProperty) {\r\n\t\t\tblockProperty = {\r\n\t\t\t\tindex: 7,\r\n\t\t\t\twriteValue: writeAsBlock\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteToken(NUMBER_CODE, id + 4) // should be in object mode\r\n\t\tvar lazyPromise = block.constructor === serialize.Block ? {\r\n\t\t\tthen: then\r\n\t\t} : {\r\n\t\t\tthen: function(callback) {\r\n\t\t\t\treturn block.then(function(value) {\r\n\t\t\t\t\tblock = value\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction then(callback) {\r\n\t\t\tvar startOffset = charEncoder.getOffset()\r\n\t\t\tvar buffer = block[bufferSymbol]\r\n\t\t\twriteToken(PROPERTY_CODE, 7)\r\n\t\t\tif (id === 0) {\r\n\t\t\t\tif (options.outlet) {\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, CONTINUED_REFERENCING_TYPE)\r\n\t\t\t\t} else {\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, REFERENCING_TYPE)\r\n\t\t\t\t}\r\n\t\t\t\twriteToken(NUMBER_CODE, UNDEFINED)\r\n\t\t\t}\r\n\t\t\tif (buffer) { // block array\r\n\t\t\t\twriteToken(SEQUENCE_CODE, buffer.length + 16) // indicate it is a block with length\r\n\t\t\t\twriteBuffer(buffer)\r\n\t\t\t} else {\r\n\t\t\t\twriteBlock(block) // write it as a block\r\n\t\t\t}\r\n\t\t\tcallback()\r\n\t\t}\r\n\t\tpendingEncodings.push(lazyPromise)\r\n\t}\r\n\r\n\tvar serializer = {\r\n\t\tserialize: function(value) {\r\n\t\t\tvar buffer = value && value[bufferSymbol]\r\n\t\t\tif (buffer) {\r\n\t\t\t\tcharEncoder.writeBuffer(buffer)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tvar startingOffset = charEncoder.getOffset()\r\n\t\t\tif (options && options.asBlock) {\r\n\t\t\t\tstartingOffset += 1\r\n\t\t\t\twriteBlock(value)\r\n\t\t\t} else {\r\n\t\t\t\twriteAsDefault(value, rootProperty)\r\n\t\t\t}\r\n\t\t\tif (pendingEncodings.length > 0) {\r\n\t\t\t\tif (options.outlet) {\r\n\t\t\t\t\t// if we have an outlet, we write the main content first, and then do the remaining blocks\r\n\t\t\t\t\t// but that should already happen naturally\r\n\t\t\t\t\tthis.rootBuffer = Buffer.from([]) // just include a rootBuffer to indicate that a sequence close token is needed\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// if there are other blocks (and no outlet) the content is deferred to go at the end, so length-defined blocks can be read first and lazily parsed\r\n\t\t\t\t\tvar endOfBlock = charEncoder.getOffset()\r\n\t\t\t\t\tvar blockBufferLength = endOfBlock - startingOffset\r\n\t\t\t\t\tvar rootBuffer = charEncoder.getSerialized()\r\n\t\t\t\t\tstartingOffset += this.startSequenceLength || 1\r\n\t\t\t\t\tthis.rootBuffer = Buffer.from(rootBuffer.slice(startingOffset)) // TODO: only if in object do we increment\r\n\t\t\t\t\tcharEncoder.setOffset(startingOffset)\r\n\t\t\t\t\t// this is a rather tricky technique, but as long as the assumption hold true, is an elegant way to handle inserting these references,\r\n\t\t\t\t\t// we are creating blocks for each pending encoding, and so we reset the next property index to before the start of the last block,\r\n\t\t\t\t\t// and let each block get its natural index\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetSerialized: function() {\r\n\t\t\tif (pendingEncodings.length > 0) {\r\n\t\t\t\tvar promises = []\r\n\t\t\t\twhile (pendingEncodings.length > 0) {\r\n\t\t\t\t\tvar finished = false\r\n\t\t\t\t\tvar promise = pendingEncodings.shift().then(function() {\r\n\t\t\t\t\t\tfinished = true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\tpromises.push(promise)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (promises.length > 0) {\r\n\t\t\t\t\treturn Promise.all(promises).then(function() {\r\n\t\t\t\t\t\treturn serializer.getSerialized()\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.rootBuffer) {\r\n\t\t\t\tcharEncoder.writeBuffer(this.rootBuffer)\r\n\t\t\t\tthis.rootBuffer = null\r\n\t\t\t\twriteToken(SEQUENCE_CODE, 13) // close sequence to end it\r\n\t\t\t}\r\n\t\t\treturn charEncoder.getSerialized()\r\n\t\t},\r\n\t\tflush: charEncoder.flush,\r\n\t\tpendingEncodings: pendingEncodings\r\n\t}\r\n\treturn serializer\r\n}\r\nfunction serialize(value, options) {\r\n\tvar serializer = createSerializer(options)\r\n\tserializer.serialize(value)\r\n\treturn serializer.getSerialized()\r\n}\r\nexports.serialize = serialize\r\nexports.createSerializer = createSerializer\r\n\r\nfunction browserCharEncoder() {\r\n\tvar serialized = ''\r\n\tfunction writeToken(type, number) {\r\n\t\tvar serializedToken\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tserializedToken = String.fromCharCode((type << 4) + number + 0x40)\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 6),\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 12),\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 18),\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 24),\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 30),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000 >>> 0),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x1000000000 >>> 0),\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000000 >>> 0),\r\n\t\t\t\t(number / 0x1000000000) & 0x3f,\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else {\r\n\t\t\tthrow new Error('Too big of number')\r\n\t\t}\r\n\t\tserialized += serializedToken\r\n\t}\r\n\tfunction writeString(string) {\r\n\t\tserialized += string\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn serialized\r\n\t}\r\n\treturn {\r\n\t\twriteToken: writeToken,\r\n\t\twriteString: writeString,\r\n\t\t//writeBuffer,\r\n\t\tgetSerialized: getSerialized,\r\n\t\t//insertBuffer,\r\n\t\t//flush,\r\n\t\tstartSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, 11)\r\n\t\t},\r\n\t\tendSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, 13)\r\n\t\t},\r\n\t\tgetOffset: function() {// unsupported\r\n\t\t\treturn -1\r\n\t\t}\r\n\t}\r\n}\r\nvar ArrayFrom = Array.from || function(iterable, keyValue) {\r\n\tvar array = []\r\n\tvar keyValue = iterable.constructor === Map\r\n\titerable.forEach(function(key, value) {\r\n\t\tif (keyValue) {\r\n\t\t\tarray.push([value, key])\r\n\t\t} else {\r\n\t\t\tarray.push(key)\r\n\t\t}\r\n\t})\r\n\treturn array\r\n}\r\n\r\nfunction writeMap(map) {\r\n\tvar keyValues = ArrayFrom(map)\r\n\tfor (var i = 0, length = keyValues.length; i < length; i++) {\r\n\t\tvar keyValue = keyValues[i]\r\n\t\tkeyValues[i] = {\r\n\t\t\tkey: keyValue[0],\r\n\t\t\tvalue: keyValue[1]\r\n\t\t}\r\n\t}\r\n\treturn keyValues\r\n}\r\nfunction writeSet(set) {\r\n\treturn ArrayFrom(set)\r\n}\r\nfunction writeDate(date) {\r\n\treturn date.getTime()\r\n}\r\n\r\n\r\n\r\nvar bufferSymbol = require('./Block').bufferSymbol\r\nvar headerSymbol = require('./Block').headerSymbol\r\nvar parsedSymbol = require('./Block').parsedSymbol\r\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\"use strict\"\r\nvar createParser = require('./lib/parse').createParser\r\n\r\nexports.XMLHttpRequest = function() {\r\n\tvar xhr = new XMLHttpRequest()\r\n\tvar parser\r\n\tvar responseResolve\r\n\tvar responseRejected\r\n   \tvar requestResolved\r\n\txhr.addEventListener('progress', receivedData)\r\n\tvar acceptSet\r\n\tvar originalSetRequestHeader = xhr.setRequestHeader\r\n\tvar lastOffset = 0\r\n\txhr.setRequestHeader = function(name, value) {\r\n\t\tif (name.toLowerCase() == 'accept')\r\n\t\t\tacceptSet = true\r\n\t\treturn originalSetRequestHeader.call(this, name, value)\r\n\t}\r\n\tvar originalSend = xhr.send\r\n\txhr.send = function() {\r\n\t\tif (!acceptSet)\r\n\t\t\tthis.setRequestHeader('Accept', 'text/dpack;q=1,application/json;q=0.7')\r\n\t\toriginalSend.apply(this, arguments)\r\n\t}\r\n\r\n\tfunction receivedData(event) {\r\n\t\tvar sourceText = xhr.responseText\r\n//\t\ttry {\r\n\t\t\tif (parser) {\r\n\t\t\t\tif (parser.onResume) {\r\n\t\t\t\t\tvar updatedData = parser.onResume(sourceText.slice(lastOffset), true, true)\r\n\t\t\t\t\txhr.responseParsed = xhr.responseParsed || updatedData\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (sourceText && /dpack/.test(xhr.getResponseHeader('Content-Type'))) {\r\n\t\t\t\t\tparser = createParser()\r\n\t\t\t\t\tparser.setSource(sourceText, 0, true)\r\n\t\t\t\t\txhr.responseParsed = parser.read()\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tlastOffset = sourceText.length\r\n/*\t\t} catch (error) {\r\n\t\t\tif (xhr.onerror) {\r\n\t\t\t\txhr.onerror(error)\r\n\t\t\t} else {\r\n\t\t\t\tthrow error\r\n\t\t\t}\r\n\t\t}*/\r\n\t}\r\n\txhr.addEventListener('load', function(event) {\r\n\t\treceivedData()\r\n\t\tif (parser && parser.isPaused()) {\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\t\t}\r\n\t})\r\n\treturn xhr\r\n}\r\n"],"sourceRoot":""}